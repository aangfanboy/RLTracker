"""
This type stub file was generated by pyright.
"""

"""Utilities for Runge Kutta solvers."""
ButcherTableau = ...
def abs_square(x):
  """Returns the squared value of `tf.abs(x)` for real and complex dtypes."""
  ...

def weighted_sum(weights, list_of_states):
  """Computes a weighted sum of `list_of_states`.

  Args:
    weights: List of scalar tensors.
    list_of_states: List of states. Every element is assumed to be of the same
      structure of Tensors. Must be of the same length as `weights`.

  Returns:
    weighted_sum: A weighted sum of states in `list_of_states`. Has the same
      structure as elements of `list_of_states`.

  Raises:
    ValueError: If `list_of_states` is empty or length doesn't match `weights`.
  """
  ...

def nest_constant(structure, value=..., dtype=...):
  """Constructs a nested structure similar to `structure` with constant values.

  Args:
    structure: A reference nested structure that is used for constant.
    value: Floating scalar setting the value of each entry of the structure.
      Default value: `1.0`.
    dtype: Optional dtype that specifies the dtype of the constant structure
      being produced. If `None`, then dtype is inferred from components of the
      structure.
      Default value: `None`.

  Returns:
    nest: Possibly nested structure of `Tensor`s with all entries equal to
    `value`. Has the same structure as `structure`.
  """
  ...

def nest_rms_norm(nest):
  """Computes root mean squared norm of nested structure of `Tensor`s.

  Args:
    nest: Possibly nested structure of `Tensor`s of which RMS norm is computed.
  Returns:
    norm: Scalar floating tensor equal to the RMS norm of `nest.
  """
  ...

def nest_where(accept_step, new_values, old_values):
  """Returns `new_values` if `accept_step` is True `old_values` otherwise.

  Uses `tf.where` on individual elements to select `new_values` or `old_values`.

  Args:
    accept_step: Scalar boolean `Tensor` indicating whether to return
      `new_values`.
    new_values: Possible nested structure of `Tensor`s.
    old_values: Possible nested structure of `Tensor`s. Must have the same
      structure as `new_values`.

  Returns:
    values: `new_values` if `accept_step` is True and `old_values` otherwise.
  """
  ...

def rk_fourth_order_interpolation_coefficients(y0, y1, k, dt, tableau): # -> list[Any]:
  """Fit an interpolating polynomial to the results of a Runge-Kutta step.

  Performs 4th order interpolation based on state and state derivative values
  determined in the Runge-Kutta state.

  Args:
    y0: State value at the start of the interval.
    y1: State value at the end of the interval.
    k: List of state values at RK k-points.
    dt: Width of the interval.
    tableau: `ButcherTableau` describing a Runge-Kutta scheme.

  Returns:
    coefficients: List of coefficients that interpolate the solution.
  """
  ...

def evaluate_interpolation(coefficients, t0, t1, t, validate_args=...):
  """Evaluates the value of polynomial interpolation at the given time point.

  Args:
    coefficients: List of `Tensor`s that hold polynomial coefficients. Must have
      length greater or equal to 2.
    t0: Scalar floating `Tensor` giving the start of the interval.
    t1: Scalar floating `Tensor` giving the end of the interval.
    t: Scalar floating `Tensor` giving the desired interpolation point.
    validate_args: Python `bool` indicating whether to validate inputs.
      Default value: False.

  Returns:
    interpolated_value: Polynomial interpolation at time `t`.

  Raises:
    ValueError: If `coefficients` has less than 2 elements.
  """
  ...

def runge_kutta_step(ode_fn, y0, f0, t0, dt, tableau, name=...): # -> tuple[Any, Any, Any, list[Any]]:
  """Take an arbitrary Runge-Kutta step and estimate error.

  Args:
    ode_fn: Callable(t, y) -> dy_dt that evaluate the time derivative of `y`.
    y0: `Tensor` initial value for the state.
    f0: `Tensor` initial value for the derivative of `y0` = `ode_fn(t0, y0)`.
    t0: `Tensor` value for the initial time.
    dt: `Tensor` value for the desired time step.
    tableau: `ButcherTableau` describing how to take the Runge-Kutta step.
    name: optional name for the operation.

  Returns:
    rk_state_tuple: Tuple `(y1, f1, y1_error, k)` giving the estimated function
      value after the Runge-Kutta step at `t1 = t0 + dt`, the derivative of the
      state at `t1`, estimated error at `t1`, and a list of Runge-Kutta
      coefficients `k` used for calculating these terms.
  """
  ...


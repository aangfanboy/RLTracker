"""
This type stub file was generated by pyright.
"""

import collections
from tensorflow_probability.python.math.ode import base

"""Dormand-Prince solver."""
__all__ = ['DormandPrince']
_TABLEAU = ...
class DormandPrince(base.Solver):
  """Dormand-Prince explicit solver for non-stiff ODEs.

  Implements 5th order Runge-Kutta with adaptive step size control
  and dense output, using the Dormand-Prince method. Similar to the 'dopri5'
  method of `scipy.integrate.ode` and MATLAB's `ode45`. For details see [1].
  For solver API see `tfp.math.ode.Solver`.

  #### References

  [1]: Shampine, L. F. (1986). Some practical runge-kutta formulas.
      Mathematics of Computation, 46(173), 135-150, doi:10.2307/2008219
  """
  ORDER = ...
  ODE_FN_EVALS_PER_STEP = ...
  def __init__(self, rtol=..., atol=..., first_step_size=..., safety_factor=..., min_step_size_factor=..., max_step_size_factor=..., max_num_steps=..., make_adjoint_solver_fn=..., validate_args=..., name=...) -> None:
    """Initializes the solver.

    Args:
      rtol: Optional float `Tensor` specifying an upper bound on relative error,
        per element of the dependent variable. The error tolerance for the next
        step is `tol = atol + rtol * abs(state)` where `state` is the computed
        state at the current step (see also `atol`). The next step is rejected
        if it incurs a local truncation error larger than `tol`.
        Default value: `1e-3`.
      atol: Optional float `Tensor` specifying an upper bound on absolute error,
        per element of the dependent variable (see also `rtol`).
        Default value: `1e-6`.
      first_step_size: Scalar float `Tensor` specifying the size of the
        first step.
        Default value: `1e-3`.
      safety_factor: Scalar positive float `Tensor`. At the end of every Runge
        Kutta step, the solver may choose to update the step size by applying a
        multiplicative factor to the current step size. This factor is `factor =
        clamp(factor_unclamped, min_step_size_factor, max_step_size_factor)`
        where `factor_unclamped = error_ratio**(-1. / (order + 1)) *
        safety_factor` (see also `min_step_size_factor` and
        `max_step_size_factor`). A small (respectively, large) value for the
        safety factor causes the solver to take smaller (respectively, larger)
        step sizes. A value larger than one, though not explicitly prohibited,
        is discouraged.
        Default value: `0.9`.
      min_step_size_factor: Scalar float `Tensor` (see `safety_factor`).
        Default value: `0.1`.
      max_step_size_factor: Scalar float `Tensor` (see `safety_factor`).
        Default value: `10.`.
      max_num_steps: Optional scalar integer `Tensor` specifying the maximum
        number of steps allowed (including rejected steps). If unspecified,
        there is no upper bound on the number of steps.
        Default value: `None`.
      make_adjoint_solver_fn: Callable that takes no arguments that constructs a
        `Solver` instance. The created solver is used in the adjoint senstivity
        analysis to compute gradients (if they are requested).
        Default value: A callable that returns this solver.
      validate_args: Whether to validate input with asserts. If `validate_args`
        is `False` and the inputs are invalid, correct behavior is not
        guaranteed.
        Default value: `False`.
      name: Python `str` name prefixed to Ops created by this function.
        Default value: `None` (i.e., 'dormand_prince').
    """
    ...
  


class _DopriDiagnostics(collections.namedtuple('_DopriDiagnostics', ['num_ode_fn_evaluations', 'num_jacobian_evaluations', 'num_matrix_factorizations', 'status']), base.Diagnostics):
  """See `tfp.math.ode.Diagnostics`."""
  __slots__ = ...


class _RungeKuttaSolverInternalState(collections.namedtuple('_RungeKuttaSolverInternalState', ['current_state', 'current_derivative', 'last_step_start', 'current_time', 'step_size', 'interpolating_coefficients'])):
  """Internal state of the Runge Kutta solver.

  Properties:
    current_state: Possibly nested structure of `Tensor`s representing the
      solution at `current_time`.
    current_derivative: Possibly nested structure of `Tensor`s representing
      time derivative of the solution at `current_time`. Must have same
      structure as `current_state`.
    last_step_start: Scalar `Tensor` representing start of the last time step.
    current_time: Scalar `Tensor` representing time of the `current_state`.
    step_size: Scalar `Tensor` representing the current time step size used by
      the solver.
    interpolating_coefficients: List of `Tensor`s giving coefficients for
      polynomial interpolation between `last_step_start` and `current_time`.
  """
  __slots__ = ...



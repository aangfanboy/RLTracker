"""
This type stub file was generated by pyright.
"""

import numpy as np

"""Utilities for Backward differentiation formula (BDF) solver."""
MAX_ORDER = ...
ORDERS = np.arange(0, MAX_ORDER + 1)
RECIPROCAL_SUMS = np.concatenate([[np.nan], np.cumsum(1 / ORDERS[1])])
def error_ratio(backward_difference, error_coefficient, tol):
  """Computes the ratio of the error in the computed state to the tolerance."""
  ...

def first_step_size(atol, first_order_error_coefficient, initial_state_vec, initial_time, ode_fn_vec, rtol, safety_factor, epsilon=..., max_step_size=..., min_step_size=...):
  """Selects the first step size to use."""
  ...

def interpolate_backward_differences(backward_differences, order, step_size_ratio):
  """Updates backward differences when a change in the step size occurs."""
  ...

def interpolation_matrix(dtype, order, step_size_ratio):
  """Creates the matrix used to interpolate backward differences."""
  ...

def newton(backward_differences, max_num_iters, newton_coefficient, ode_fn_vec, order, step_size, time, tol, unitary, upper): # -> tuple[Any, Any, Any, Any]:
  """Runs Newton's method to solve the BDF equation."""
  ...

_NewtonIterand = ...
def newton_qr(jacobian_mat, newton_coefficient, step_size): # -> tuple[Any, Any]:
  """QR factorizes the matrix used in each iteration of Newton's method."""
  ...

def update_backward_differences(backward_differences, next_backward_difference, next_state_vec, order):
  """Returns the backward differences for the next time."""
  ...


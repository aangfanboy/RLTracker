"""
This type stub file was generated by pyright.
"""

"""Utilities for TensorFlow Probability ODE solvers."""
class Bunch(dict):
  """Dict-subclass which exposes keys as attributes."""
  def __getattr__(self, name):
    ...
  
  def __setattr__(self, name, value): # -> None:
    ...
  
  def __delattr__(self, name): # -> None:
    ...
  


def assert_increasing(tensor, identifier):
  """Assert if a `Tensor` is strictly increasing."""
  ...

def assert_nonnegative(tensor, identifier):
  """Assert if a `Tensor` is nonnegative."""
  ...

def assert_positive(tensor, identifier):
  """Assert if a `Tensor` is positive."""
  ...

def error_if_not_real_or_complex(tensor, identifier): # -> None:
  """Raise a `TypeError` if the `Tensor` is neither real nor complex."""
  ...

def error_if_not_vector(tensor, identifier): # -> None:
  """Raise a `ValueError` if the `Tensor` is not 1-D."""
  ...

def get_jacobian_fn_mat(jacobian_fn, ode_fn_vec, state_shape, dtype): # -> _AutomaticJacobian | Callable[..., Any]:
  """Returns a wrapper around the user-specified `jacobian_fn` argument.

  `jacobian_fn` is an optional argument that can either be a constant `Tensor`
  or a function of the form `jacobian_fn(time, state)`. This function returns a
  wrapper `jacobian_fn_mat(time, state_vec)` whose second argument and output
  are 1 and 2-D `Tensor`s, respectively, corresponding reshaped versions of
  `state` and `jacobian_fn(time, state)`.

  Args:
    jacobian_fn: User-specified `jacobian_fn` passed to `solve`.
    ode_fn_vec: Result of `get_ode_fn_vec`.
    state_shape: The shape of the second argument and output of `ode_fn`.
    dtype: If `jacobian_fn` is constant, what dtype to convert it to.

  Returns:
    The wrapper described above.
  """
  ...

def get_state_vec(state):
  """Converts a possibly nested state into a vector."""
  ...

def get_state_from_vec(state_vec, state_shape):
  """Inverse of `get_state_vec`."""
  ...

def get_ode_fn_vec(ode_fn, state_shape): # -> Callable[..., Any]:
  """Returns a wrapper around the user-specified `ode_fn` argument.

  The second argument and output of `ode_fn(time, state)` are N-D `Tensor`s.
  This function returns a wrapper `ode_fn_vec(time, state_vec)` whose
  second argument and output are 1-D `Tensor`s corresponding to reshaped
  versions of `state` and `ode_fn(time, state)`.

  Args:
    ode_fn: User-specified `ode_fn` passed to `solve`.
    state_shape: The shape of the second argument and output of `ode_fn`.

  Returns:
    The wrapper described above.
  """
  ...

def next_step_size(step_size, order, error_ratio, safety_factor, min_step_size_factor, max_step_size_factor):
  """Computes the next step size to use.

  Computes the next step size by applying a multiplicative factor to the current
  step size. This factor is
  ```none
  factor_unclamped = error_ratio**(-1. / (order + 1)) * safety_factor
  factor = clamp(factor_unclamped, min_step_size_factor, max_step_size_factor)
  ```

  Args:
    step_size: Scalar float `Tensor` specifying the current step size.
    order: Scalar integer `Tensor` specifying the order of the method.
    error_ratio: Scalar float `Tensor` specifying the ratio of the error in the
      computed state and the tolerance.
    safety_factor: Scalar float `Tensor`.
    min_step_size_factor: Scalar float `Tensor` specifying a lower bound on the
      multiplicative factor.
    max_step_size_factor: Scalar float `Tensor` specifying an upper bound on the
      multiplicative factor.

  Returns:
    Scalar float `Tensor` specifying the next step size.
  """
  ...

def stop_gradient_of_real_or_complex_entries(nested):
  """Calls `tf.stop_gradient` on real or complex elements of a nested structure.

  Args:
    nested: The nested structure. May contain `Tensor`s with different `dtype`s.

  Returns:
    The resulting nested structure.
  """
  ...

def right_mult_by_jacobian_mat(jacobian_fn_mat, ode_fn_vec, time, state_vec, vec):
  """Right multiplies a vector by the Jacobian.

  The Jacobian is constructed by calling `jacobian_fn_mat(time, state_vec)` if
  doing so does not require automatic differentiation. Otherwise, chain rule
  automatic differentiation is applied to `ode_fn_vec` to obtain the Jacobian.

  Args:
    jacobian_fn_mat: Result of `get_jacobian_fn_mat`.
    ode_fn_vec: Result of `get_ode_fn_vec`.
    time: Scalar float `Tensor` time at which to evalute the Jacobian.
    state_vec: `Tensor` state at which to evaluate the Jacobian.
    vec: `Tensor` with shape is compatible with the Jacobian.

  Returns:
    `Tensor` representing the dot product.
  """
  ...

class _AutomaticJacobian:
  """Callable that returns a Jacobian computed by automatic differentiation."""
  def __init__(self, ode_fn_vec) -> None:
    ...
  
  def __call__(self, time, state_vec):
    ...
  



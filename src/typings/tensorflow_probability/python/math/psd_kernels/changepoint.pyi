"""
This type stub file was generated by pyright.
"""

from tensorflow_probability.python.math.psd_kernels import positive_semidefinite_kernel as psd_kernel

"""Change point kernel."""
__all__ = ['ChangePoint']
class ChangePoint(psd_kernel.AutoCompositeTensorPsdKernel):
  """Changepoint Kernel.


  Given a list of kernels `k_1`, `k_2`, ..., `k_n`, and 1-D inputs `x` and `y`,
  this kernel computes a smooth interpolant between the kernels.

  ```none
  k(x, y) = (1 - s_1(x)) * k_1(x, y) * (1 - s1(y)) +
            (1 - s_2(x)) * s_1(x) * k_2(x, y) * (1 - s_2(y)) * s_1(y) +
            (1 - s_3(x)) * s_2(x) * k_3(x, y) * (1 - s_3(y)) * s_2(y) +
            ...
            s_{n-1}(x) * kn(x, y) * s_{n-1}(y)
  ```

  where:
    * `s_i(x) = sigmoid(slopes[i] * (x - locs[i]))`
    * `locs` is a `Tensor` of length `n - 1` that's in ascending order.
    * `slopes` is a positive `Tensor` of length `n - 1`.

  If we have 2 kernels `k1` and `k2`, this takes the form:

  ```none
  k(x, y) = (1 - s_1(x)) * k_1(x, y) * (1 - s_1(y)) +
            s_1(x) * k_2(x, y) * s_1(y)
  ```

  When `x` and `y` are much less than `locs[0]`, `k(x, y) ~= k1(x, y)`, while
  `x` and `y` are much greater than `locs[0]`, `k(x, y) ~= k2(x, y)`.

  In general, this kernel performs a smooth interpolation between `ki(x, y)`
  where `k(x, y) ~= ki(x, y)` when `locs[i - 1] < x, y < locs[i]`.

  This kernel accepts an optional `weight_fn` which consumes `x` and returns
  a scalar. This is used when computing the sigmoids
  `si(x) = sigmoid(slopes[i] * (w(x) - locs[i]))`, which allows this kernel
  to be computed on arbitrary dimensional input. For instance, a `weight_fn`
  that is `tf.linalg.norm` would smoothly interpolate between different kernels
  over different annuli in the plane.

  #### References
  [1]: Andrew Gordon Wilson. The Change Point Kernel.
       https://www.cs.cmu.edu/~andrewgw/changepoints.pdf
  """
  def __init__(self, kernels, locs, slopes, weight_fn=..., validate_args=..., name=...) -> None:
    """Construct a ChangePoint kernel instance.

    Args:
      kernels: List of size `[N]` of `PositiveSemidefiniteKernel` instances to
        interpolate between.
      locs: Ascending Floating-point `Tensor` of shape broadcastable to
        `[..., N - 1]` that controls the regions for the interpolation.
        If `kernels` are a list of 1-D kernels with the default `weight_fn`,
        then between `locs[i - 1]` and `locs[i]`, this kernel acts like
        `kernels[i]`.
      slopes: Positive Floating-point `Tensor` of shape broadcastable to
        `[..., N - 1]` that controls how smooth the interpolation between
        kernels is (larger `slopes` means more discrete transitions).
      weight_fn: Python `callable` which takes an input `x` and `feature_ndims`
        argument, and returns a `Tensor` where a scalar is returned for
        each right-most `feature_ndims` of the input.
        (in other words, if `x` is a batch of inputs, `weight_fn` returns
        a batch of scalar, with the same batch shape).
        Default value: Sums over the last `feature_ndims` of the input `x`.
      validate_args: If `True`, parameters are checked for validity despite
        possibly degrading runtime performance
      name: Python `str` name prefixed to Ops created by this class.
    """
    ...
  
  @property
  def kernels(self): # -> Any:
    ...
  
  @property
  def locs(self):
    ...
  
  @property
  def slopes(self):
    ...
  
  @property
  def weight_fn(self): # -> Callable[..., object]:
    ...
  



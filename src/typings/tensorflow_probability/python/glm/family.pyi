"""
This type stub file was generated by pyright.
"""

import tensorflow.compat.v2 as tf

"""Generalized Linear Model specifications."""
__all__ = ['Bernoulli', 'BernoulliNormalCDF', 'Binomial', 'CustomExponentialFamily', 'ExponentialFamily', 'GammaExp', 'GammaSoftplus', 'LogNormal', 'LogNormalSoftplus', 'NegativeBinomial', 'NegativeBinomialSoftplus', 'Normal', 'NormalReciprocal', 'Poisson', 'PoissonSoftplus']
class ExponentialFamily(tf.Module):
  """Specifies a mean-value parameterized exponential family.

  Subclasses implement [exponential-family distribution](
  https://en.wikipedia.org/wiki/Exponential_family) properties (e.g.,
  `log_prob`, `variance`) as a function of a real-value which is transformed via
  some [link function](
  https://en.wikipedia.org/wiki/Generalized_linear_model#Link_function)
  to be interpreted as the distribution's mean. The distribution is
  parameterized by this mean, i.e., "mean-value parameterized."

  Subclasses are typically used to specify a Generalized Linear Model (GLM). A
  [GLM]( https://en.wikipedia.org/wiki/Generalized_linear_model) is a
  generalization of linear regression which enables efficient fitting of
  log-likelihood losses beyond just assuming `Normal` noise. See `tfp.glm.fit`
  for more details.

  Subclasses must implement `_as_distribution` which does not need to be either
  "tape-safe" or "variable-safe." (`tfp.glm` families are however guaranteed to
  be both tape and variable safe.)

  Subclasses may optionally implement `_call` and `_log_prob` which otherwise
  default to:

  ```python
  def _call(self, predicted_linear_response):
    with tf.GradientTape(watch_accessed_variables=False) as tape:
      tape.watch(predicted_linear_response)
      likelihood = self.as_distribution(predicted_linear_response)
      mean = likelihood.mean()
    variance = likelihood.variance()
    grad_mean = tape.gradient(mean, predicted_linear_response)
    return mean, variance, grad_mean

  def _log_prob(self, response, predicted_linear_response):
    likelihood = self.as_distribution(predicted_linear_response)
    return likelihood.log_prob(response)
  ```

  In context of `tfp.glm.fit` and `tfp.glm.fit_sparse`, these functions are used
  to find the best fitting weights for given model matrix ("X") and responses
  ("Y").
  """
  def __init__(self, name=...) -> None:
    """Creates the ExponentialFamily.

    Args:
      name: Python `str` used as TF namescope for ops created by member
        functions. Default value: `None` (i.e., the subclass name).
    """
    ...
  
  def __call__(self, predicted_linear_response, name=...): # -> tuple[Any, Any, Any]:
    """Computes `mean(r), var(mean), d/dr mean(r)` for linear response, `r`.

    Here `mean` and `var` are the mean and variance of the sufficient statistic,
    which may not be the same as the mean and variance of the random variable
    itself.  If the distribution's density has the form

    ```none
    p_Y(y) = h(y) Exp[dot(theta, T(y)) - A]
    ```

    where `theta` and `A` are constants and `h` and `T` are known functions,
    then `mean` and `var` are the mean and variance of `T(Y)`.  In practice,
    often `T(Y) := Y` and in that case the distinction doesn't matter.

    Args:
      predicted_linear_response: `float`-like `Tensor` corresponding to
        `tf.linalg.matmul(model_matrix, weights)`.
      name: Python `str` used as TF namescope for ops created by member
        functions. Default value: `None` (i.e., 'call').

    Returns:
      mean: `Tensor` with shape and dtype of `predicted_linear_response`
        representing the distribution prescribed mean, given the prescribed
        linear-response to mean mapping.
      variance: `Tensor` with shape and dtype of `predicted_linear_response`
        representing the distribution prescribed variance, given the prescribed
        linear-response to mean mapping.
      grad_mean: `Tensor` with shape and dtype of `predicted_linear_response`
        representing the gradient of the mean with respect to the
        linear-response and given the prescribed linear-response to mean
        mapping.
    """
    ...
  
  def log_prob(self, response, predicted_linear_response, name=...):
    """Computes `D(param=mean(r)).log_prob(response)` for linear response, `r`.

    Args:
      response: `float`-like `Tensor` representing observed ("actual")
        responses.
      predicted_linear_response: `float`-like `Tensor` corresponding to
        `tf.linalg.matmul(model_matrix, weights)`.
      name: Python `str` used as TF namescope for ops created by member
        functions. Default value: `None` (i.e., 'log_prob').

    Returns:
      log_prob: `Tensor` with shape and dtype of `predicted_linear_response`
        representing the distribution prescribed log-probability of the observed
        `response`s.
    """
    ...
  
  def as_distribution(self, predicted_linear_response, name=...):
    """Builds a mean parameterized TFP Distribution from linear response.

    Example:

    ```python
    model = tfp.glm.Bernoulli()
    r = tfp.glm.compute_predicted_linear_response(x, w)
    yhat = model.as_distribution(r)
    ```

    Args:
      predicted_linear_response: `response`-shaped `Tensor` representing linear
        predictions based on new `model_coefficients`, i.e.,
        `tfp.glm.compute_predicted_linear_response(
           model_matrix, model_coefficients, offset)`.
      name: Python `str` used as TF namescope for ops created by member
        functions. Default value: `None` (i.e., 'log_prob').

    Returns:
      model: `tfp.distributions.Distribution`-like object with mean
        parameterized by `predicted_linear_response`.
    """
    ...
  
  def __str__(self) -> str:
    ...
  
  def __repr__(self): # -> str:
    ...
  


class CustomExponentialFamily(ExponentialFamily):
  """Constucts GLM from arbitrary distribution and inverse link function."""
  def __init__(self, distribution_fn, linear_model_to_mean_fn, name=...) -> None:
    """Creates the `CustomExponentialFamily`.

    Args:
      distribution_fn: Python `callable` which returns a
        `tf.distribution.Distribution`-like instance from a single input
        representing the distribution's required `mean`, i.e.,
        `mean = linear_model_to_mean_fn(matmul(model_matrix, weights))`.
      linear_model_to_mean_fn: Python `callable` which returns the
        distribution's required mean as computed from the predicted linear
        response, `tf.linalg.matmul(model_matrix, weights)`.
      name: Python `str` used as TF namescope for ops created by member
        functions. Default value: `None` (i.e., the subclass name).
    """
    ...
  
  @property
  def distribution_fn(self): # -> Any:
    ...
  
  @property
  def linear_model_to_mean_fn(self): # -> Callable[..., Any] | Any:
    ...
  


class Bernoulli(ExponentialFamily):
  """`Bernoulli(probs=mean)` where `mean = sigmoid(X @ weights)`."""
  ...


class BernoulliNormalCDF(ExponentialFamily):
  """`Bernoulli(probs=mean)` where `mean = Normal(0, 1).cdf(X @ weights)`."""
  ...


class Binomial(ExponentialFamily):
  """`Binomial(total_count, probs=mean)`.

  Where `mean = total_count * sigmoid(matmul(X, weights))`.
  """
  def __init__(self, total_count=..., name=...) -> None:
    ...
  


class GammaExp(ExponentialFamily):
  """`Gamma(concentration=1, rate=1 / mean)` where `mean = exp(X @ w))`."""
  def __init__(self, concentration=..., name=...) -> None:
    ...
  


class GammaSoftplus(ExponentialFamily):
  """`Gamma(concentration=1, rate=1 / mean)` where `mean = softplus(X @ w))`."""
  def __init__(self, concentration=..., name=...) -> None:
    ...
  


class Poisson(ExponentialFamily):
  """`Poisson(rate=mean)` where `mean = exp(X @ weights)`."""
  ...


class PoissonSoftplus(ExponentialFamily):
  """`Poisson(rate=mean)` where `mean = softplus(X @ weights)`."""
  ...


class LogNormal(ExponentialFamily):
  """`LogNormal(loc=log(mean) - log(2) / 2, scale=sqrt(log(2)))` where
  `mean = exp(X @ weights)`.
  """
  def __init__(self, scale=..., name=...) -> None:
    ...
  


class LogNormalSoftplus(ExponentialFamily):
  """`LogNormal(loc=log(mean) - log(2) / 2, scale=sqrt(log(2)))`
  `mean = softplus(X @ weights)`.
  """
  def __init__(self, scale=..., name=...) -> None:
    ...
  


class Normal(ExponentialFamily):
  """`Normal(loc=mean, scale=1)` where `mean = X @ weights`."""
  def __init__(self, scale=..., name=...) -> None:
    ...
  


class NormalReciprocal(ExponentialFamily):
  """`Normal(loc=mean, scale=1)` where `mean = 1 / (X @ weights)`."""
  def __init__(self, scale=..., name=...) -> None:
    ...
  


class NegativeBinomial(ExponentialFamily):
  """`NegativeBinomial(total_count, probs=mean / (mean + total_count))`.

  Where `mean = exp(X @ weights)`.
  """
  def __init__(self, total_count=..., name=...) -> None:
    ...
  


class NegativeBinomialSoftplus(ExponentialFamily):
  """`NegativeBinomial(total_count, probs=mean / (mean + total_count))`.

  Where `mean = softplus(X @ weights)`.
  """
  def __init__(self, total_count=..., name=...) -> None:
    ...
  



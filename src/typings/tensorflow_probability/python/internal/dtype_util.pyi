"""
This type stub file was generated by pyright.
"""

"""Utility functions for dtypes."""
__all__ = ['as_numpy_dtype', 'assert_same_float_dtype', 'base_dtype', 'base_equal', 'common_dtype', 'eps', 'is_bool', 'is_complex', 'is_floating', 'is_integer', 'is_numpy_compatible', 'max', 'min', 'name', 'real_dtype', 'size']
JAX_MODE = ...
NUMPY_MODE = ...
SKIP_DTYPE_CHECKS = ...
_issubdtype = ...
if JAX_MODE:
  _issubdtype = ...
def is_numpy_compatible(dtype): # -> Literal[True]:
  """Returns if dtype has a corresponding NumPy dtype."""
  ...

def as_numpy_dtype(dtype):
  """Returns a `np.dtype` based on this `dtype`."""
  ...

def base_dtype(dtype): # -> None:
  """Returns a non-reference `dtype` based on this `dtype`."""
  ...

def base_equal(a, b):
  """Returns `True` if base dtypes are identical."""
  ...

class _NotYetSeen:
  """Sentinel class for uninspected arguments' dtype."""
  def __repr__(self): # -> Literal['...']:
    ...
  


_NOT_YET_SEEN = ...
def common_dtype(args, dtype_hint=...):
  """Returns (nested) explict dtype from `args` if there is one.

  Args:
    args: A nested structure of objects that may have `dtype`. If `dtype_hint`
      is not nested, then the structure of `args` is flattened and ignored. If
      `dtype_hint` is nested, then `args` is interpreted as a depth-1
      iterable or mapping, each element of which is an object with dtype of
      this structure (or dtype `None`), a nested structure with this shallow
      structure, or `None`. This enables unification of dtypes between
      objects of nested dtype and nested structures of arrays.
    dtype_hint: Optional (nested) dtype containing defaults to use in place of
      `None`. If `dtype_hint` is not nested and the common dtype of `args` is
      nested, `dtype_hint` serves as the default for each element of the common
      nested dtype structure.

  Returns:
    dtype: The (nested) dtype common across all elements of `args`, or `None`.

  #### Examples

  Usage with non-nested dtype:

  ```python
  x = tf.ones([3, 4], dtype=tf.float64)
  y = 4.
  z = None
  common_dtype([x, y, z], dtype_hint=tf.float32)  # ==> tf.float64
  common_dtype([y, z], dtype_hint=tf.float32)     # ==> tf.float32

  # The arg to `common_dtype` can be an arbitrary nested structure; it is
  # flattened, and the common dtype of its contents is returned.
  common_dtype({'x': x, 'yz': (y, z)})
  # ==> tf.float64
  ```

  Usage with nested dtype:

  ```python
  # Define `x` and `y` as JointDistributions with the same nested dtype.
  x = tfd.JointDistributionNamed(
      {'a': tfd.Uniform(np.float64(0.), 1.),
       'b': tfd.JointDistributionSequential(
          [tfd.Normal(0., 2.), tfd.Bernoulli(0.4)])})
  x.dtype  # ==> {'a': tf.float64, 'b': [tf.float32, tf.int32]}

  y = tfd.JointDistributionNamed(
      {'a': tfd.LogitNormal(np.float64(0.), 1.),
       'b': tfd.JointDistributionSequential(
          [tfd.Normal(-1., 1.), tfd.Bernoulli(0.6)])})
  y.dtype  # ==> {'a': tf.float64, 'b': [tf.float32, tf.int32]}

  # Pack x and y into an arbitrary nested structure and pass it to
  # `common_dtype`.
  args0 = [x, y]
  common_dtype(args0)  # ==> {'a': tf.float64, 'b': [tf.float32, tf.int32]}

  # If `dtype_hint` is not structured, the nested structure of the argument
  # to `common_dtype` is flattened and ignored, and only the nested structures
  # of the dtypes are relevant.
  args1 = {'x': x, 'yz': {'y': y, 'z': None}}
  common_dtype(args1)  # ==> {'a': tf.float64, 'b': [tf.float32, tf.int32]}

  # Use structured `dtype_hint` to indicate the structure of the expected dtype.
  # In this example, `x` is an object with structured dtype, and `t` is a
  # a structure of objects whose dtypes are compatible with the corresponding
  # components of `x.dtype`. Without structured `dtype_hint`, this example
  # would fail, since the args `[x, t]` would be flattened entirely, and the
  # structured `x.dtype` is incompatible with the non-structured `float32`
  # contained in `t`.
  t = {'a': [1., 2., 3.], 'b': [np.float32(1.), [[4, 5]]]}
  common_dtype([x, t], dtype_hint={'a': None, 'b': [None, None]})
  #   ==> {'a': tf.float64, 'b': [tf.float32, tf.int32]}
  ```
  """
  ...

def convert_to_dtype(tensor_or_dtype, dtype=..., dtype_hint=...): # -> None:
  """Get a dtype from a list/tensor/dtype using convert_to_tensor semantics."""
  ...

def eps(dtype): # -> floating[Any]:
  """Returns the distance between 1 and the next largest representable value."""
  ...

def is_bool(dtype): # -> bool:
  """Returns whether this is a boolean data type."""
  ...

def is_complex(dtype): # -> bool:
  """Returns whether this is a complex floating point type."""
  ...

def is_floating(dtype): # -> bool:
  """Returns whether this is a (non-quantized, real) floating point type."""
  ...

def is_integer(dtype): # -> bool:
  """Returns whether this is a (non-quantized) integer type."""
  ...

def max(dtype): # -> floating[Any] | int:
  """Returns the maximum representable value in this data type."""
  ...

def min(dtype): # -> floating[Any] | int:
  """Returns the minimum representable value in this data type."""
  ...

def name(dtype): # -> str:
  """Returns the string name for this `dtype`."""
  ...

def size(dtype): # -> int:
  """Returns the number of bytes to represent this `dtype`."""
  ...

def real_dtype(dtype):
  """Returns the dtype of the real part."""
  ...

def assert_same_float_dtype(tensors=..., dtype=...):
  """Validate and return float type based on `tensors` and `dtype`.

  For ops such as matrix multiplication, inputs and weights must be of the
  same float type. This function validates that all `tensors` are the same type,
  validates that type is `dtype` (if supplied), and returns the type. Type must
  be a floating point type. If neither `tensors` nor `dtype` is supplied,
  the function will return `dtypes.float32`.

  Args:
    tensors: Tensors of input values. Can include `None` elements, which will
      be ignored.
    dtype: Expected type.

  Returns:
    Validated type.

  Raises:
    ValueError: if neither `tensors` nor `dtype` is supplied, or result is not
      float, or the common type of the inputs is not a floating point type.
  """
  ...


"""
This type stub file was generated by pyright.
"""

import weakref

"""Utilities for bijector-caches."""
__all__ = ['BijectorCache', 'BijectorCacheWithGreedyAttrs']
def hashable_structure(struct): # -> tuple[tuple[Any, ObjectIdentityWrapper | None], ...]:
  """Hashes a possibly mutable structure of `Tensor`s."""
  ...

class ObjectIdentityWrapper:
  """Wraps an object, mapping __eq__ on wrapper to 'is' on wrapped."""
  __slots__ = ...
  def __init__(self, wrapped, object_hash=...) -> None:
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __ne__(self, other) -> bool:
    ...
  
  def __hash__(self) -> int:
    ...
  


class HashableWeakRef(weakref.ref):
  """weakref.ref which makes tf.Tensor and np.array objects hashable.

  We take care to ensure that a hash can still be provided in the case that the
  ref has been cleaned up. This ensures that the WeakKeyDefaultDict doesn't
  suffer memory leaks by failing to clean up HashableWeakRef key objects whose
  referrents have gone out of scope and been destroyed (as in
  https://github.com/tensorflow/probability/issues/647).
  """
  __slots__ = ...
  def __init__(self, referrent, callback=...) -> None:
    """weakref.ref which makes tf.Tensor and np.array objects hashable.

    Args:
      referrent: Object that is being referred to.
      callback: Optional callback to invoke when object is GCed.
    """
    ...
  
  def __repr__(self): # -> str:
    ...
  
  def __hash__(self) -> int:
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __ne__(self, other) -> bool:
    ...
  


class WeakStructRef:
  """weakref.ref object for tensors, np.ndarray, and structures.

  Invokes the callback when any element of the struct's ref-count drops to 0.
  """
  __slots__ = ...
  def __init__(self, struct, subkey=..., callback=...) -> None:
    ...
  
  @property
  def alive(self): # -> bool:
    ...
  
  def cancel(self): # -> None:
    ...
  
  @property
  def ref_set(self): # -> set[None]:
    """Returns the set of unique references."""
    ...
  
  @property
  def subkey(self): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
    """Returns the subkey associated with the struct."""
    ...
  
  def __call__(self): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
    """Unwraps the tensor reference."""
    ...
  
  def __hash__(self) -> int:
    """Returns the cached hash of this structure."""
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __repr__(self): # -> str:
    ...
  
  def __bool__(self): # -> bool:
    ...
  


_DirectedFunctionInvocation = ...
class EphemeralDict(dict):
  """`dict` that enables unbound weakref callback."""
  def __init__(self, *args, **kwargs) -> None:
    ...
  


class BijectorCache:
  """Caches a weak chain of transformations for all bijector instances.

  On a cache miss, the other side of the transformation is produced
  and both sides are cached before returning a result. The input object
  is cached with a strong reference, while the transformed output is
  held weakly. When there are no more references to the result, both
  directions of the mapping are cleared simultaneously.

  The general contracts are:
    1) The inputs used on cache misses will always be retained
       until their corresponding outputs are abandoned.
    2) `forward` will return a cached result if and only if
       `inverse` would have returned a cached result.

  Retaining results in such a manner guarantees that there will be no
  circular references, allowing the garbage collector to remove "dead"
  links from the cache.

  Example usage:

  ```py
  bij = MyBijector()
  cache = BijectorCache(bijector=bij)

  x = tf.constant(1.)
  ref = weakref.ref(x)

  for i in range(10):
    assert (len(cache.weak_keys(direction='forward'))
            == len(cache.weak_keys(direction='inverse'))
            == i)
    x = cache.forward(x)

  for i in range(10):
    assert len(cache.weak_keys(direction='inverse')) == 10 - i
    x = cache.inverse(x)
    assert len(cache.weak_keys(direction='forward')) == 10 - i

  assert len(cache.weak_keys(direction='inverse')) == 0
  assert ref() == x

  x = None
  assert len(cache.weak_keys(direction='forward')) == 0
  ```
  """
  def __init__(self, forward_name=..., inverse_name=..., bijector=..., bijector_class=..., storage=...) -> None:
    """Constructs the BijectorCache.

    Args:
      forward_name: `str`, name of the bijectors' forward transformations.
      inverse_name: `str`, name of the bijectors' inverse transformations.
      bijector: `tfb.Bijector` instance, or None for an unbound cache.
      bijector_class: Type of `bijector`, or None for an unbound cache.
      storage: `EphemeralDict` instance or None.
    """
    ...
  
  def __get__(self, bijector, bijector_class=...): # -> Self:
    """Defines cache behavior when accessed as a bijector attribute.

    We define `__get__` so that the object can be used as a `Bijector` class
    attribute and still access the (eventual) `Bijector` instance without
    requiring that the `Bijector` instance pass `self` back into this cache.

    Args:
      bijector: a `tfb.Bijector` instance to which the cache is bound.
      bijector_class: Type of `bijector`.

    Returns:
      cache: A `BijectorCache` instance bound to `bijector`.
    """
    ...
  
  @property
  def bijector(self): # -> None:
    ...
  
  @property
  def bijector_class(self): # -> None:
    ...
  
  def forward(self, x, **kwargs): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
    """Invokes the 'forward' transformation, or looks up previous results.

    Args:
      x: The singular argument passed to `bijector._forward`.
      **kwargs: Any auxiliary arguments passed to the function.
        These reflect shared context to the function, and are associated
        with both the input and output cache-keys.
    Returns:
      The output of the bijector's `_forward` method, or a cached result.
    """
    ...
  
  def inverse(self, y, **kwargs): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
    """Invokes the 'inverse' transformation, or looks up previous results.

    Args:
      y: The singular argument passed to `bijector._inverse`.
      **kwargs: Any auxiliary arguments passed to the function.
        These reflect shared context to the function, and are associated
        with both the input and output cache-keys.
    Returns:
      The output of the bijector's `_inverse` method, or a cached result.
    """
    ...
  
  def forward_attributes(self, x, **kwargs):
    ...
  
  def inverse_attributes(self, y, **kwargs):
    ...
  
  def weak_keys(self, bijector=..., bijector_class=..., direction=...): # -> list[Any]:
    """Returns the keys in input_cache."""
    ...
  
  def items(self, bijector=..., bijector_class=..., direction=...): # -> list[tuple[Any, Any]]:
    ...
  
  def __len__(self): # -> int:
    """Returns the length of the input cache.

    This may differ from the output cache when lazily-defined attributes exist
    """
    ...
  
  def clear(self): # -> None:
    """Clears cached values.

    If the cache is bound to a bijector instance, all entries in the cache keyed
    by the hash of the bijector instance are cleared. If the cache is bound to
    a bijector class, all entries keyed by the class are cleared. If the cache
    is unbound, the cache storage is re-instantiated as an empty EphemeralDict.
    """
    ...
  


class BijectorCacheWithGreedyAttrs(BijectorCache):
  """A CachedDirectedFunction that updates attributes when called.

  Expects the wrapped function to return an `(out, attributes)` tuple.
  Updates the cached attributes based on the second element of the response.
  """
  ...



"""
This type stub file was generated by pyright.
"""

"""Reimplementation of `tensorflow.python.util.nest` using dm-tree.

This module defines aliases which allow to use `tree` as drop-in replacement
for TensorFlow's `nest`.

Usage:
```python
from tensorflow_probability.python.internal.backend.numpy import nest
nest.pack_sequence_as(..., ...)
```
"""
ObjectProxy = ...
JAX_MODE = ...
_SHALLOW_TREE_HAS_INVALID_KEYS = ...
_STRUCTURES_HAVE_MISMATCHING_TYPES = ...
_STRUCTURES_HAVE_MISMATCHING_LENGTHS = ...
_INPUT_TREE_SMALLER_THAN_SHALLOW_TREE = ...
_IF_SHALLOW_IS_SEQ_INPUT_MUST_BE_SEQ = ...
assert_same_structure = ...
def assert_shallow_structure(shallow_tree, input_tree, check_types=...): # -> None:
  """Asserts that `shallow_tree` is a shallow structure of `input_tree`.

  That is, this function recursively tests if each key in shallow_tree has its
  corresponding key in input_tree.

  Examples:

  The following code will raise an exception:

  ```python
  shallow_tree = {"a": "A", "b": "B"}
  input_tree = {"a": 1, "c": 2}
  assert_shallow_structure(shallow_tree, input_tree)
  ```

  ```none
  ValueError: The shallow_tree's keys are not a subset of the input_tree's ...
  ```

  The following code will raise an exception:

  ```python
  shallow_tree = ["a", "b"]
  input_tree = ["c", ["d", "e"], "f"]
  assert_shallow_structure(shallow_tree, input_tree)
  ```

  ```
  ValueError: The two structures don't have the same sequence length.
  ```

  By setting check_types=False, we drop the requirement that corresponding
  nodes in shallow_tree and input_tree have to be the same type. Sequences
  are treated equivalently to Mappables that map integer keys (indices) to
  values. The following code will therefore not raise an exception:

  ```python
  assert_shallow_structure({0: "foo"}, ["foo"], check_types=False)
  ```

  Args:
    shallow_tree: an arbitrarily nested structure.
    input_tree: an arbitrarily nested structure.
    check_types: if `True` (default) the sequence types of `shallow_tree` and
      `input_tree` have to be the same.

  Raises:
    TypeError: If `shallow_tree` is a sequence but `input_tree` is not.
    TypeError: If the sequence types of `shallow_tree` are different from
      `input_tree`. Only raised if `check_types` is `True`.
    ValueError: If the sequence lengths of `shallow_tree` are different from
      `input_tree`.
  """
  ...

def flatten(structure, expand_composites=...):
  """Add expand_composites support for JAX."""
  ...

def flatten_up_to(*args, expand_composites=..., **kwargs): # -> list[Any]:
  ...

def flatten_with_joined_string_paths(structure, separator=..., expand_composites=...): # -> list[tuple[str, Any]]:
  """Returns a list of (string path, data element) tuples.

  The order of tuples produced matches that of `nest.flatten`. This allows you
  to flatten a nested structure while keeping information about where in the
  structure each data element was located. See `nest.yield_flat_paths`
  for more information.

  Args:
    structure: the nested structure to flatten.
    separator: string to separate levels of hierarchy in the results, defaults
      to '/'.
    expand_composites: Python bool included for compatibility; `True` values
      are not supported.

  Returns:
    A list of (string, data element) tuples.
  """
  ...

def flatten_with_tuple_paths(structure, expand_composites=...): # -> list[tuple[tuple[()], Any] | tuple[tuple[()] | Any, Any]]:
  ...

def flatten_with_tuple_paths_up_to(shallow_structure, input_structure, check_types=..., expand_composites=...): # -> list[tuple[tuple[()], Any] | tuple[tuple[()] | Any, Any]]:
  ...

_FALSE_SENTINEL = ...
def get_traverse_shallow_structure(traverse_fn, structure): # -> defaultdict[Any, Any] | MappingProxyType[Any, Any] | Mapping[Any, Any] | dict[Any, Any] | list[Any] | Any | ObjectProxy:
  """Generates a shallow structure from a `traverse_fn` and `structure`.

  `traverse_fn` must accept any possible subtree of `structure` and return
  a depth=1 structure containing `True` or `False` values, describing which
  of the top-level subtrees may be traversed.  It may also
  return scalar `True` or `False` 'traversal is OK / not OK for all subtrees.'

  Examples are available in the unit tests (nest_test.py).

  Args:
    traverse_fn: Function taking a substructure and returning either a scalar
      `bool` (whether to traverse that substructure or not) or a depth=1 shallow
      structure of the same type, describing which parts of the substructure to
      traverse.
    structure: The structure to traverse.

  Returns:
    A shallow structure containing python bools, which can be passed to
    `map_up_to` and `flatten_up_to`.

  Raises:
    TypeError: if `traverse_fn` returns a sequence for a non-sequence input,
      or a structure with depth higher than 1 for a sequence input,
      or if any leaf values in the returned structure or scalar are not type
      `bool`.
  """
  ...

is_nested = ...
def map_structure(func, *structure, **kwargs): # -> object | defaultdict[Any, Any] | MappingProxyType[Any, Any] | Mapping[Any, Any] | dict[Any, Any] | list[Any] | Any | ObjectProxy:
  """Add expand_composites support for JAX."""
  ...

def map_structure_up_to(shallow_structure, func, *structures, **kwargs): # -> defaultdict[Any, Any] | MappingProxyType[Any, Any] | Mapping[Any, Any] | dict[Any, Any] | list[Any] | Any | ObjectProxy:
  ...

def map_structure_with_tuple_paths(func, *structures, **kwargs): # -> defaultdict[Any, Any] | MappingProxyType[Any, Any] | Mapping[Any, Any] | dict[Any, Any] | list[Any] | Any | ObjectProxy:
  ...

def map_structure_with_tuple_paths_up_to(shallow_structure, func, *structures, expand_composites=..., **kwargs): # -> defaultdict[Any, Any] | MappingProxyType[Any, Any] | Mapping[Any, Any] | dict[Any, Any] | list[Any] | Any | ObjectProxy:
  """Wraps nest.map_structure_with_path_up_to, with structure/type checking."""
  ...

def pack_sequence_as(structure, flat_sequence, **kwargs): # -> defaultdict[Any, Any] | MappingProxyType[Any, Any] | Mapping[Any, Any] | dict[Any, Any] | list[Any] | Any | ObjectProxy:
  ...

def yield_flat_paths(nest, expand_composites=...): # -> Generator[tuple[()] | Any, Any, None]:
  """Yields paths for some nested structure.

  Paths are lists of objects which can be str-converted, which may include
  integers or other types which are used as indices in a dict.

  The flat list will be in the corresponding order as if you called
  `flatten` on the structure. This is handy for naming Tensors such
  the TF scope structure matches the tuple structure.

  E.g. if we have a tuple `value = Foo(a=3, b=Bar(c=23, d=42))`

  >>> Foo = collections.namedtuple('Foo', ['a', 'b'])
  >>> Bar = collections.namedtuple('Bar', ['c', 'd'])
  >>> value = Foo(a=3, b=Bar(c=23, d=42))

  >>> flatten(value)
  [3, 23, 42]

  >>> list(yield_flat_paths(value))
  [('a',), ('b', 'c'), ('b', 'd')]

  >>> list(yield_flat_paths({'a': [3]}))
  [('a', 0)]

  >>> list(yield_flat_paths({'a': 3}))
  [('a',)]

  Args:
    nest: the value to produce a flattened paths list for.
    expand_composites: Python bool included for compatibility; `True` values
      are not supported.
  Yields:
    Tuples containing index or key values which form the path to a specific
      leaf value in the nested structure.
  """
  ...


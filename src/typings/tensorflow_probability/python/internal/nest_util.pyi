"""
This type stub file was generated by pyright.
"""

"""Utilities dealing with nested structures."""
__all__ = ['broadcast_structure', 'call_fn', 'cast_structure', 'expand_as_args', 'map_structure_with_named_args']
_is_namedtuple = ...
UNSPECIFIED = ...
_STRUCTURES_HAVE_MISMATCHING_TYPES = ...
_STRUCTURES_HAVE_MISMATCHING_LENGTHS = ...
_SHALLOW_TREE_HAS_INVALID_KEYS = ...
_IF_SHALLOW_IS_SEQ_INPUT_MUST_BE_SEQ = ...
def broadcast_structure(to_structure, from_structure):
  """Broadcasts `from_structure` to `to_structure`.

  This is useful for downstream usage of `zip` or `tf.nest.map_structure`.

  If `from_structure` is a singleton, it is tiled to match the structure of
  `to_structure`. Note that the elements in `from_structure` are not copied if
  this tiling occurs.

  Args:
    to_structure: A structure.
    from_structure: A structure.

  Returns:
    new_from_structure: Same structure as `to_structure`.

  #### Example:

  ```python
  a_structure = ['a', 'b', 'c']
  b_structure = broadcast_structure(a_structure, 'd')
  # -> ['d', 'd', 'd']
  c_structure = tf.nest.map_structure(
      lambda a, b: a + b, a_structure, b_structure)
  # -> ['ad', 'bd', 'cd']
  ```
  """
  ...

def cast_structure(value, structure): # -> Any:
  """Cast a structure."""
  ...

def map_structure_with_named_args(func, *structures, _check_types=..., _expand_composites=..., _up_to=..., **named_structures): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
  """Calls `nest.map_structure` with named args.

  Args:
    func: a callable that accepts one or more named arguments.
    *structures: Structures of arguments passed positionally to `func`.
    _check_types: Forwarded as `map_structure(..., check_types=_check_types)`.
    _expand_composites: Forwarded as
      `map_structure(..., expand_composites=_expand_composites)`.
    _up_to: Optional shallow structure to map up to. If provided,
      `nest.map_structure_up_to` is called rather than `nest.map_structure`.
      Default value: `UNSPECIFIED`.
    **named_structures: Structures of arguments passed by name to `func`.
  Returns:
    A new structure matching that of the input structures (or the shallow
      structure `_up_to`, if specified), in which each element is computed
      by applying `func` to the corresponding elements of the input structures.

  #### Examples

  ```python
  func = lambda x, y: 2 * x + 3 * y

  map_structure_with_named_args(func, [1, 2], [10, 11])
  # ==> [32, 37]

  map_structure_with_named_args(func, [1, 2], y=[10, 11])
  # ==> [32, 37]

  map_structure_with_named_args(func, x=[1, 2], y=[10, 11])
  # ==> [32, 37]

  map_structure_with_named_args(func, [10, 11], x=[1, 2])
  # ==> TypeError: <lambda>() got multiple values for argument 'x'.
  ```

  """
  ...

def map_structure_coroutine(coroutine, *structures, _expand_composites=..., _up_to=..., _with_tuple_paths=..., **named_structures): # -> Generator[Any, Any, Any | defaultdict[Any, Any] | list[Any] | None]:
  """Invokes a coroutine multiple times with args from provided structures.

  This is semantically identical to `map_structure_with_named_args`, except
  that the first argument is a generator or coroutine (a callable whose body
  contains `yield` statements) rather than a function. This is invoked with
  arguments from the provided structure(s), thus defining an outer generator/
  coroutine that `yield`s values in sequence from each call to the inner
  `coroutine`.

  The argument structures are traversed, and the coroutine is invoked, in
  the order defined by `tf.nest.flatten`. A stripped-down implementation of
  the core logic is as follows:

  ```python
  def map_structure_coroutine(coroutine, *structures):
    flat_results = []
    for args in zip(*[tf.nest.flatten(s) for s in structures]):
      retval = yield from coroutine(*args)
      flat_results.append(retval)
    return tf.nest.pack_sequence_as(structures[0], flat_results)
  ```

  Args:
    coroutine: a generator/coroutine callable that accepts one or more named
      arguments.
    *structures: Structures of arguments passed positionally to `coroutine`.
    _expand_composites: Forwarded as
      `tf.nest.flatten(..., expand_composites=_expand_composites)`.
    _up_to: Optional shallow structure to map up to. If provided,
      `nest.map_structure_up_to` is called rather than `nest.map_structure`.
      Default value: `UNSPECIFIED`.
    _with_tuple_paths: Python bool. If `True`, the first argument to `coroutine`
      is a tuple path to the current leaf of the argument structure(s).
      Default value: `False`.
    **named_structures: Structures of arguments passed by name to `coroutine`.
  Yields:
    Values `yield`ed by each invocation of `coroutine`, with invocations in
      order corresponding to `tf.nest.flatten`.
  Returns:
    A new structure matching that of the input structures (or the shallow
      structure `_up_to`, if specified), in which each element is the return
      value from applying `coroutine` to the corresponding elements of the input
      structures.

  ## Examples

  A JointDistributionCoroutine may define a reusable submodel as its own
  coroutine, for example:

  ```python
  def horseshoe_prior(path, scale):
    # Auxiliary-variable representation of a horseshoe prior on sparse weights.
    name = ','.join(path)
    z = yield tfd.HalfCauchy(loc=0., scale=scale, name=name + '_z')
    w_noncentered = yield tfd.Normal(
        loc=0., scale=z, name=name + '_w_noncentered')
    return z * w_noncentered
  ```

  Note that this submodel yields two auxiliary random variables, and returns the
  sampled weight as a third value.

  Using `map_structure_coroutine` we can define a structure of such submodels,
  and collect their return values:

  ```
  @tfd.JointDistributionCoroutineAutoBatched
  def model():
    weights = yield from nest_util.map_structure_coroutine(
        horseshoe_prior,
        scale={'a': tf.ones([5]) * 100., 'b': tf.ones([2]) * 1e-2},
        _with_tuple_paths=True)
    # ==> `weights` is a dict of weight values.
    yield tfd.Deterministic(
        tf.sqrt(tf.norm(weights['a'])**2 + tf.norm(weights['b'])**2),
        name='weights_norm')

  print(model.event_shape)
  # ==> StructTuple(
  #       a_z=TensorShape([5]),
  #       a_w_noncentered=TensorShape([5]),
  #       b_z=TensorShape([2]),
  #       b_w_noncentered=TensorShape([2]),
  #       weights_norm=TensorShape([]))
  ```
  """
  ...

def expand_as_args(args): # -> bool:
  """Returns `True` if `args` should be expanded as `*args`."""
  ...

def convert_args_to_tensor(args, dtype=..., name=...): # -> defaultdict[Any, Any] | Any | list[Any] | None:
  """Converts `args` to `Tensor`s.

  Use this when it is necessary to convert user-provided arguments that will
  then be passed to user-provided callables.

  When `dtype` is `None` this function behaves as follows:

  1A. If the top-level structure is a `list`/`tuple` but not a `namedtuple`,
      then it is left as is and only its elements are converted to `Tensor`s.

  2A. The sub-structures are converted to `Tensor`s eagerly. E.g. if `args` is
      `{'arg': [[1], [2]]}` it is converted to
      `{'arg': tf.constant([[1], [2]])}`. If the conversion fails, it will
      attempt to recurse into its children.

  When `dtype` is specified, it acts as both a structural and numeric type
  constraint. `dtype` can be a single `DType`, `None` or a nested collection
  thereof. The conversion rule becomes as follows:

  1B. The return value of this function will have the same structure as `dtype`.

  2B. If the leaf of `dtype` is a concrete `DType`, then the corresponding
      sub-structure in `args` is converted to a `Tensor`.

  3B. If the leaf of `dtype` is `None`, then the corresponding sub-structure is
      converted eagerly as described in the rule 2A above.

  Args:
    args: Arguments to convert to `Tensor`s.
    dtype: Optional structure/numeric type constraint.
    name: Optional name-scope to use.

  Returns:
    args: Converted `args`.

  #### Examples.

  This table shows some useful conversion cases. `T` means `Tensor`, `NT` means
  `namedtuple` and `CNT` means a `namedtuple` with a `Tensor`-conversion
  function registered.

  |     args     |    dtype   |       output       |
  |:------------:|:----------:|:------------------:|
  | `{"a": 1}`   | `None`     | `{"a": T(1)}`      |
  | `T(1)`       | `None`     | `T(1)`             |
  | `[1]`        | `None`     | `[T(1)]`           |
  | `[1]`        | `tf.int32` | `T([1])`           |
  | `[[T(1)]]`   | `None`     | `[T([1])]`         |
  | `[[T(1)]]`   | `[[None]]` | `[[T(1)]]`         |
  | `NT(1, 2)`   | `None`     | `NT(T(1), T(2))`   |
  | `NT(1, 2)`   | `tf.int32` | `T([1, 2])`        |
  | `CNT(1, 2)`  | `None`     | `T(...)`           |
  | `[[1, [2]]]` | `None`     | `[[T(1), T([2])]]` |

  """
  ...

def call_fn(fn, args):
  """Calls `fn` with `args`, possibly expanding `args`.

  Use this function when calling a user-provided callable using user-provided
  arguments.

  The expansion rules are as follows:

  `fn(*args)` if `args` is a `list` or a `tuple`, but not a `namedtuple`.
  `fn(**args)` if `args` is a `dict`.
  `fn(args)` otherwise.

  Args:
    fn: A callable that takes either `args` as an argument(s).
    args: Arguments to `fn`.

  Returns:
    result: Return value of `fn`.
  """
  ...

def convert_to_nested_tensor(value, dtype=..., dtype_hint=..., allow_packing=..., as_shape_tensor=..., convert_ref=..., name=...): # -> Any | defaultdict[Any, Any] | list[Any] | None:
  """Converts the given `value` to a (structure of) `Tensor`.

  This function converts Python objects of various types to a (structure of)
  `Tensor` objects. It accepts `Tensor` objects, numpy arrays, Python lists, and
  Python scalars.

  Args:
    value: An object whose structure matches that of `dtype` and for which each
      leaf has a registered `Tensor` conversion function.
    dtype: Optional structure of dtypes defining the structure of outputs and
      the `dtype` argument for nested calls to `convert_to_tensor`. If not
      nested, will be broadcasted to match the structure of `dtype_hint`.
    dtype_hint: Optional structure of dtypes defining the structure of outputs
      and the `dtype_hint` argument for nested calls to `convert_to_tensor`. If
      not nested, will be broadcasted to match the structure of `dtype`.
    allow_packing: Python `bool`, default `False`. If `True`, allow
      `convert_to_nested_tensor` to stack nested lists of Tensors along the
      leading dimension. Otherwise, raise.
    as_shape_tensor: Optional boolean when if `True` uses
      `prefer_static.convert_to_shape_tensor` instead of `tf.convert_to_tensor`
      for JAX compatibility.
    convert_ref: Python `bool`, default `True`. If `True`, convert objects with
      reference semantics to Tensor.
    name: Optional name to use if a new `Tensor` is created. If inputs are
      structured, elements are named accoring to '{name}/{path}.{to}.{elem}'.

  Returns:
    tensor: A (structure of) `Tensor` based on `value`.
  """
  ...

class _DotString:
  def __str__(self) -> str:
    ...
  
  def __repr__(self): # -> Literal['.']:
    ...
  


_DOT = ...
def coerce_structure(shallow_tree, input_tree): # -> defaultdict[Any, Any] | Any | list[Any] | None:
  """Coerces the containers in `input_tree` to exactly match `shallow_tree`.

  This method largely parallels the behavior of `nest.assert_shallow_structure`,
  but allows `namedtuples` to be interpreted as either sequences or mappings.
  It returns a structure with the container-classes found in `shallow_tree`
  and the contents of `input_tree`, such that `shallow_tree` and `input_tree`
  may be used safely in downstream calls to `nest.map_structure_up_to`.

  Note: this method does not currently support `expand_composites`.

  Example Usage:
  ```python

  ab = collections.namedtuple('AB', 'a b')(0, 1)
  ba = collections.namedtuple('BA', 'b a')(2, 3)

  coerce_structure(ab, ba)
  # -> AB(a=3, b=2)
  ```

  Args:
    shallow_tree: A (shallow) structure to be populated.
    input_tree: A (parallel) structure of values.
  Returns:
    A structure with containers from shallow_tree and values from input_tree.
  Raises:
    ValueError: When nested sub-structures have differing lengths.
    ValueError: When nested sub-structures have different keys.
    TypeError: When `shallow_tree` is deeper than `input_tree`
    TypeError: When nested sub-structures are incompatible (e.g., list vs dict).
  """
  ...


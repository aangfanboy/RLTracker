"""
This type stub file was generated by pyright.
"""

from tensorflow.python.framework import composite_tensor, type_spec

"""Turns arbitrary objects into tf.CompositeTensor."""
JAX_MODE = ...
__all__ = ['auto_composite_tensor', 'AutoCompositeTensor', 'is_deferred_assertion_context']
_DEFERRED_ASSERTION_CONTEXT = ...
def is_composite_tensor(value): # -> bool:
  """Returns True for CTs and non-CT custom pytrees in JAX mode.

  Args:
    value: A TFP component (e.g. a distribution or bijector instance) or object
      that behaves as one.

  Returns:
    value_is_composite: bool, True if `value` is a `CompositeTensor` in TF mode
      or a non-leaf pytree in JAX mode.
  """
  ...

def is_deferred_assertion_context(): # -> Any | bool:
  ...

_registry = ...
_SENTINEL = ...
_AUTO_COMPOSITE_TENSOR_VERSION = ...
_sig_cache = ...
class _AutoCompositeTensorTypeSpec(type_spec.BatchableTypeSpec):
  """A tf.TypeSpec for `AutoCompositeTensor` objects."""
  __slots__ = ...
  def __init__(self, param_specs, non_tensor_params, omit_kwargs, prefer_static_value, non_identifying_kwargs, callable_params=...) -> None:
    """Initializes a new `_AutoCompositeTensorTypeSpec`.

    Args:
      param_specs: Python `dict` of `tf.TypeSpec` instances that describe
        kwargs to the `AutoCompositeTensor`'s constructor that are `Tensor`-like
        or `CompositeTensor` subclasses.
      non_tensor_params: Python `dict` containing non-`Tensor` and non-
        `CompositeTensor` kwargs to the `AutoCompositeTensor`'s constructor.
      omit_kwargs: Python `tuple` of strings corresponding to the names of
        kwargs to the `AutoCompositeTensor`'s constructor that should be omitted
        from the `_AutoCompositeTensorTypeSpec`'s serialization, equality/
        compatibility checks, and rebuilding of the `AutoCompositeTensor` from
        `Tensor` components.
      prefer_static_value: Python `tuple` of strings corresponding to the names
        of `Tensor`-like kwargs to the `AutoCompositeTensor`s constructor that
        may be stored as static values, if known. These are typically shapes or
        axis values.
      non_identifying_kwargs: Python `tuple` of strings corresponding to the
        names of kwargs to the `AutoCompositeTensor`s constructor whose values
        are not relevant to the unique identification of the
        `_AutoCompositeTensorTypeSpec` instance. Equality/comparison checks and
        `__hash__` do not depend on these kwargs.
      callable_params: Python `dict` of callable kwargs to the
        `AutoCompositeTensor`'s constructor that do not subclass
        `CompositeTensor`, or `None`. If `callable_params` is a non-empty
        `dict`, then serialization of the `_AutoCompositeTensorTypeSpec` is not
         supported. Defaults to `None`, which is converted to an empty `dict`.
    """
    ...
  
  @classmethod
  def from_instance(cls, instance, omit_kwargs=..., non_identifying_kwargs=...): # -> Self:
    ...
  
  def is_subtype_of(self, other): # -> bool:
    """Returns True if `self` is subtype of `other`.

    Args:
      other: A `TypeSpec`.
    """
    ...
  
  def most_specific_common_supertype(self, others): # -> Self | None:
    """Returns the most specific supertype of `self` and `others`.

    Args:
      others: A Sequence of `TypeSpec`.

    Returns `None` if a supertype does not exist.
    """
    ...
  
  def is_compatible_with(self, spec_or_value): # -> Literal[False]:
    """Returns true if `spec_or_value` is compatible with this TypeSpec."""
    ...
  
  def __repr__(self): # -> str:
    ...
  
  def __reduce__(self): # -> tuple[type[Self], Any]:
    ...
  
  def __eq__(self, other) -> bool:
    ...
  
  def __ne__(self, other) -> bool:
    ...
  
  def __hash__(self) -> int:
    ...
  


class AutoCompositeTensor(composite_tensor.CompositeTensor):
  """Recommended base class for `@auto_composite_tensor`-ified classes.

  See details in `tfp.experimental.auto_composite_tensor` description.
  """
  ...


def type_spec_register(name, allow_overwrite=...): # -> Callable[..., type[TypeSpec]]:
  """Decorator used to register a unique name for a TypeSpec subclass.

  Unlike TensorFlow's `type_spec_registry.register`, this function allows a new
  `TypeSpec` to be registered with a `name` that already appears in the
  registry (overwriting the `TypeSpec` already registered with that name). This
  allows for re-definition of `AutoCompositeTensor` subclasses in test
  environments and iPython.

  Args:
    name: The name of the type spec. Must have the form
    `"{project_name}.{type_name}"`.  E.g. `"my_project.MyTypeSpec"`.
    allow_overwrite: `bool`, if `True` then the entry in the `TypeSpec` registry
      keyed by `name` will be overwritten if it exists. If `False`, then
      behavior is the same as `type_spec.register`.

  Returns:
    A class decorator that registers the decorated class with the given name.
  """
  ...

def auto_composite_tensor(cls=..., omit_kwargs=..., non_identifying_kwargs=..., module_name=...): # -> partial[Any] | type[CompositeTensor] | type[_AutoCompositeTensor]:
  """Automagically generate `CompositeTensor` behavior for `cls`.

  `CompositeTensor` objects are able to pass in and out of `tf.function` and
  `tf.while_loop`, or serve as part of the signature of a TF saved model.

  The contract of `auto_composite_tensor` is that all __init__ args and kwargs
  must have corresponding public or private attributes (or properties). Each of
  these attributes is inspected (recursively) to determine whether it is (or
  contains) `Tensor`s or non-`Tensor` metadata. Nested (`list`, `tuple`, `dict`,
  etc) attributes are supported, but must either contain *only* `Tensor`s (or
  lists, etc, thereof), or *no* `Tensor`s. E.g.,
    - object.attribute = [1., 2., 'abc']                        # valid
    - object.attribute = [tf.constant(1.), [tf.constant(2.)]]   # valid
    - object.attribute = ['abc', tf.constant(1.)]               # invalid

  All `__init__` args that may be `ResourceVariable`s must also admit `Tensor`s
  (or else `_convert_variables_to_tensors` must be overridden).

  If the attribute is a callable, serialization of the `TypeSpec`, and therefore
  interoperability with `tf.saved_model`, is not currently supported. As a
  workaround, callables that do not contain or close over `Tensor`s may be
  expressed as functors that subclass `AutoCompositeTensor` and used in place of
  the original callable arg:

  ```python
  @auto_composite_tensor(module_name='my.module')
  class F(AutoCompositeTensor):

    def __call__(self, *args, **kwargs):
      return original_callable(*args, **kwargs)
  ```

  Callable objects that do contain or close over `Tensor`s should either
  (1) subclass `AutoCompositeTensor`, with the `Tensor`s passed to the
  constructor, (2) subclass `CompositeTensor` and implement their own
  `TypeSpec`, or (3) have a conversion function registered with
  `type_spec.register_type_spec_from_value_converter`.

  If the object has a `_composite_tensor_shape_parameters` field (presumed to
  have `tuple` of `str` value), the flattening code will use
  `tf.get_static_value` to attempt to preserve shapes as static metadata, for
  fields whose name matches a name specified in that field. Preserving static
  values can be important to correctly propagating shapes through a loop.
  Note that the Distribution and Bijector base classes provide a
  default implementation of `_composite_tensor_shape_parameters`, populated by
  `parameter_properties` annotations.

  If the decorated class `A` does not subclass `CompositeTensor`, a *new class*
  will be generated, which mixes in `A` and `CompositeTensor`.

  To avoid this extra class in the class hierarchy, we suggest inheriting from
  `auto_composite_tensor.AutoCompositeTensor`, which inherits from
  `CompositeTensor` and implants a trivial `_type_spec` @property. The
  `@auto_composite_tensor` decorator will then overwrite this trivial
  `_type_spec` @property. The trivial one is necessary because `_type_spec` is
  an abstract property of `CompositeTensor`, and a valid class instance must be
  created before the decorator can execute -- without the trivial `_type_spec`
  property present, `ABCMeta` will throw an error! The user may thus do any of
  the following:

  #### `AutoCompositeTensor` base class (recommended)
  ```python
  @tfp.experimental.auto_composite_tensor
  class MyClass(tfp.experimental.AutoCompositeTensor):
    ...

  mc = MyClass()
  type(mc)
  # ==> MyClass
  ```

  #### No `CompositeTensor` base class (ok, but changes expected types)
  ```python
  @tfp.experimental.auto_composite_tensor
  class MyClass(object):
    ...

  mc = MyClass()
  type(mc)
  # ==> MyClass_AutoCompositeTensor
  ```

  #### `CompositeTensor` base class, requiring trivial `_type_spec`
  ```python
  from tensorflow.python.framework import composite_tensor
  @tfp.experimental.auto_composite_tensor
  class MyClass(composite_tensor.CompositeTensor):
    @property
    def _type_spec(self):  # will be overwritten by @auto_composite_tensor
      pass
    ...

  mc = MyClass()
  type(mc)
  # ==> MyClass
  ```

  ## Full usage example

  ```python
  @tfp.experimental.auto_composite_tensor(omit_kwargs=('name',))
  class Adder(tfp.experimental.AutoCompositeTensor):
    def __init__(self, x, y, name=None):
      with tf.name_scope(name or 'Adder') as name:
        self._x = tf.convert_to_tensor(x)
        self._y = tf.convert_to_tensor(y)
        self._name = name

    def xpy(self):
      return self._x + self._y

  def body(obj):
    return Adder(obj.xpy(), 1.),

  result, = tf.while_loop(
      cond=lambda _: True,
      body=body,
      loop_vars=(Adder(1., 1.),),
      maximum_iterations=3)

  result.xpy()  # => 5.
  ```

  Args:
    cls: The class for which to create a CompositeTensor subclass.
    omit_kwargs: Optional sequence of kwarg names to be omitted from the spec.
    non_identifying_kwargs: Optional sequence of kwarg names to be omitted from
      equality/comparison checks and the `__hash__` method of the spec.
    module_name: The module name with which to register the `TypeSpec`. If
      `None`, defaults to `cls.__module__`.

  Returns:
    composite_tensor_subclass: A subclass of `cls` and TF CompositeTensor.
  """
  class _GeneratedCTTypeSpec(_AutoCompositeTensorTypeSpec):
    ...
  
  
  class _AutoCompositeTensor(cls, composite_tensor.CompositeTensor):
    """A per-`cls` subclass of `CompositeTensor`."""
    ...
  
  

def convert_variables_to_tensors(obj):
  """Recursively converts Variables in the AutoCompositeTensor to Tensors.

  This method flattens `obj` into a nested structure of `Tensor`s or
  `CompositeTensor`s, converts any `ResourceVariable`s (which are
  `CompositeTensor`s) to `Tensor`s, and rebuilds `obj` with `Tensor`s in place
  of `ResourceVariable`s.

  The usage of `obj._type_spec._from_components` violates the contract of
  `CompositeTensor`, since it is called on a different nested structure
  (one containing only `Tensor`s) than `obj.type_spec` specifies (one that may
  contain `ResourceVariable`s). Since `AutoCompositeTensor`'s
  `_from_components` method passes the contents of the nested structure to
  `__init__` to rebuild the TFP object, and any TFP object that may be
  instantiated with `ResourceVariables` may also be instantiated with
  `Tensor`s, this usage is valid.

  Args:
    obj: An `AutoCompositeTensor` instance.

  Returns:
    tensor_obj: `obj` with all internal `ResourceVariable`s converted to
      `Tensor`s.
  """
  ...

def pytree_flatten(obj): # -> tuple[tuple[Any, ...] | tuple[()], tuple[tuple[Any, ...] | tuple[()], dict[str, Any]]]:
  """Flatten method for JAX pytrees."""
  ...

def pytree_unflatten(cls, aux_data, children):
  """Unflatten method for JAX pytrees."""
  ...


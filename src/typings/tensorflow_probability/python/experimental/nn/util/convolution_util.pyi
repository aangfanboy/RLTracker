"""
This type stub file was generated by pyright.
"""

"""Functions for framing `conv` as `matmul`."""
__all__ = ['im2row', 'im2row_index', 'make_convolution_fn', 'make_convolution_transpose_fn_with_dilation', 'make_convolution_transpose_fn_with_subkernels', 'make_convolution_transpose_fn_with_subkernels_matrix']
def im2row(x, block_shape, slice_step=..., padding=..., name=...):
  """Rearrange image blocks into rows.

  This function can be used to implement 2D convolution as a `matmul`, e.g.,

  `tf.nn.conv2d(x, k) = tf.matmul(
      tf.experimental.nn.util.im2row(x), tf.reshape(k, shape=[-1, out_size]))`.

  Args:
    x: Rank 3 (or more) Tensor representing 2D images.
    block_shape: Length-2 vector representing the block or "filter" shape.
    slice_step: Length-2 vector specifying the convolution stride length.
      Default value: `(1, 1)`.
    padding: One of `'VALID'` or `'SAME'` (case insensitive).
      Default value: `'VALID'`.
    name: Python `str` used to describe ops created by this function.
      Default value: `None` (i.e., `'im2col'`).

  Returns:
    im2row_x: batch of matrices representing subblock copies of `x`.
      Same batch shape as `x` but with rightmost shape:
      `batch_shape + [oh * ow, block_shape[0] * block_shape[1] * channels]`,
      where `oh = (h - block_shape[0] + 1) // slice_step[0]` and
      `ow = (w - block_shape[1] + 1) // slice_step[1]` when `padding = 'VALID'`
      and `oh = h` and `ow = w` when `padding = 'SAME'`.
    shape: shape `Tensor` equivalent to:
      `batch_shape + [oh, ow, block_shape[0] * block_shape[1] * channels]` where
      `oh, ow` are defined as above.
  """
  ...

def im2row_index(input_shape, block_shape, rank=..., slice_step=..., dilations=..., dtype=..., transpose=..., validate_args=..., name=...): # -> tuple[int, Any]:
  """Computes indexes into a flattened image for building `im2row`."""
  ...

def cartesian_add(xs): # -> int:
  """Adds a list of vectors by cumulatively expanding a dimension."""
  ...

def make_convolution_fn(filter_shape, rank, strides, padding, dilations=..., dtype=..., validate_args=..., name=...): # -> Callable[..., Any]:
  """Like `tf.nn.conv2d` except applies batch of kernels to batch of `x`."""
  ...

def make_convolution_transpose_fn_with_dilation(filter_shape, strides, padding, rank=..., dilations=..., dtype=..., validate_args=..., name=...): # -> Callable[..., Any]:
  """Like `tf.nn.conv2d` except applies batch of kernels to batch of `x`.

  This version tends to be fastest on GPU. It implements the transposed
  convolution as a regular convolution of an image that is dilated by
  interleaving rows and columns of zeros equal to the number of strides.

  Args:
    filter_shape: ...
    strides: ...
    padding: ...
    rank: ...
    dilations: ...
    dtype: ...
    validate_args: ...
    name: ...
  Returns:
    convolution_transpose_fn: A callable that takes an input `Tensor` and kernel
      and applies the transpose convolution operation.
  """
  ...

def make_convolution_transpose_fn_with_subkernels_matrix(filter_shape, strides, padding, rank=..., dilations=..., dtype=..., validate_args=..., name=...): # -> Callable[..., Any]:
  """Like `tf.nn.conv2d` except applies batch of kernels to batch of `x`."""
  ...

def make_convolution_transpose_fn_with_subkernels(filter_shape, strides, padding, rank=..., dilations=..., dtype=..., validate_args=..., name=...): # -> Callable[..., Any]:
  """Like `tf.nn.conv2d` except applies batch of kernels to batch of `x`."""
  ...

def prepare_conv_args(filter_shape, rank, strides, padding, dilations, is_transpose=..., validate_args=...): # -> tuple[tuple[Any, ...] | Any, int, tuple[Any, ...] | Any, tuple[str, ...] | str, tuple[Any, ...] | Any]:
  """Sanitizes use provided input."""
  ...

def prepare_tuple_argument(arg, n, arg_name, validate_args=...): # -> tuple[Any, ...]:
  """Helper which processes `Tensor`s to tuples in standard form."""
  ...


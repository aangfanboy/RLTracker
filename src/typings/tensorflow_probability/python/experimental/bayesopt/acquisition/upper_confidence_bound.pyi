"""
This type stub file was generated by pyright.
"""

from tensorflow_probability.python.experimental.bayesopt.acquisition import acquisition_function

"""Upper Confidence Bound."""
class ParallelUpperConfidenceBound(acquisition_function.AcquisitionFunction):
  """Parallel upper confidence bound acquisition function.

  Computes the q-UCB based on observed data using a stochastic process surrogate
  model. The computation is of the form `mean + exploration * stddev`.

  Requires that `predictive_distribution` has a `sample` method.

  #### Examples

  Build and evaluate a Parallel Upper Confidence Bound acquisition function.

  ```python
  import numpy as np
  import tensorflow_probability as tfp

  tfd = tfp.distributions
  tfpk = tfp.math.psd_kernels
  tfp_acq = tfp.experimental.bayesopt.acquisition

  # Sample 10 20-dimensional index points and associated observations.
  index_points = np.random.uniform(size=[10, 20])
  observations = np.random.uniform(size=[10])

  # Build a GP regression model conditioned on observed data.
  dist = tfd.GaussianProcessRegressionModel(
      kernel=tfpk.ExponentiatedQuadratic(),
      observation_index_points=index_points,
      observations=observations)

  gp_pucb = tfp_acq.ParallelUpperConfidenceBound(
      predictive_distribution=dist,
      observations=observations,
      exploration=0.05,
      num_samples=int(2e4))

  # Evaluate the acquisition function at a set of predictive index points.
  pred_index_points = np.random.uniform(size=[6, 20])
  acq_fn_vals = gp_pucb(pred_index_points)  # Has shape [6].
  ```

  """
  def __init__(self, predictive_distribution, observations, seed=..., exploration=..., num_samples=..., transform_fn=...) -> None:
    """Parallel Upper Confidence Bound acquisition function.

    Args:
      predictive_distribution: `tfd.Distribution`-like, the distribution over
        observations at a set of index points. Must have a `sample` method.
      observations: `Float` `Tensor` of observations. Shape has the form
        `[b1, ..., bB, e]`, where `e` is the number of index points (such that
        the event shape of `predictive_distribution` is `[e]`) and
        `[b1, ..., bB]` is broadcastable with the batch shape of
        `predictive_distribution`.
      seed: PRNG seed; see tfp.random.sanitize_seed for details.
      exploration: Exploitation-exploration trade-off parameter.
      num_samples: The number of samples to use for the Paralle Expected
        Improvement approximation.
      transform_fn: Optional Python `Callable` that transforms objective values.
        This is used for optimizing a composite grey box function `g(f(x))`
        where `f` is our black box function and `g` is `transform_fn`.
    """
    ...
  
  @property
  def exploration(self): # -> float:
    ...
  
  @property
  def num_samples(self): # -> int:
    ...
  
  @property
  def transform_fn(self): # -> None:
    ...
  
  @property
  def is_parallel(self): # -> Literal[True]:
    ...
  
  def __call__(self, **kwargs):
    """Computes the Parallel Upper Confidence Bound.

    Args:
      **kwargs: Keyword args passed on to the `sample` method of
        `predictive_distribution`.

    Returns:
      Parallel upper confidence bounds at index points implied by
      `predictive_distribution` (or overridden in `**kwargs`).

    #### References
    [1] J. Wilson, R. Moriconi, F. Hutter, M. Deisenroth
    The reparameterization trick for acquisition functions
    https://bayesopt.github.io/papers/2017/32.pdf
    """
    ...
  


class GaussianProcessUpperConfidenceBound(acquisition_function.AcquisitionFunction):
  """Analytical Gaussian Process upper confidence bound acquisition function.

  Computes the analytic sequential upper confidence bound for a Gaussian
  process model.

  Requires that `predictive_distribution` has a `.mean`, `stddev` method.

  #### Examples

  Build and evaluate a GP Upper Confidence Bound acquisition function.

  ```python
  import numpy as np
  import tensorflow_probability as tfp

  tfd = tfp.distributions
  tfpk = tfp.math.psd_kernels
  tfp_acq = tfp.experimental.bayesopt.acquisition

  # Sample 12 5-dimensional index points and associated observations.
  index_points = np.random.uniform(size=[12, 5])
  observations = np.random.uniform(size=[12])

  # Build a GP regression model conditioned on observed data.
  dist = tfd.GaussianProcessRegressionModel(
      kernel=tfpk.ExponentiatedQuadratic(),
      observation_index_points=index_points,
      observations=observations)

  # Build a GP upper confidence bound acquisition function.
  gp_ucb = tfp_acq.GausianProcessUpperConfidenceBound(
      predictive_distribution=dist,
      observations=observations,
      exploration=0.05,
      num_samples=int(2e4))

  # Evaluate the acquisition function at a set of 6 predictive index points.
  pred_index_points = np.random.uniform(size=[6, 5])
  acq_fn_vals = gp_ucb(pred_index_points)  # Has shape [6].
  ```

  """
  def __init__(self, predictive_distribution, observations, seed=..., exploration=...) -> None:
    """Constructs a GP Upper Confidence Bound acquisition function.

    Args:
      predictive_distribution: `tfd.Distribution`-like, the distribution over
        observations at a set of index points. Must have `mean`, `stddev`
        methods.
      observations: `Float` `Tensor` of observations. Shape has the form
        `[b1, ..., bB, e]`, where `e` is the number of index points (such that
        the event shape of `predictive_distribution` is `[e]`) and
        `[b1, ..., bB]` is broadcastable with the batch shape of
        `predictive_distribution`.
      seed: PRNG seed; see tfp.random.sanitize_seed for details.
      exploration: Exploitation-exploration trade-off parameter.
    """
    ...
  
  @property
  def exploration(self): # -> float:
    ...
  
  def __call__(self, **kwargs):
    """Computes analytic GP upper confidence bound.

    Args:
      **kwargs: Keyword args passed on to the `mean` and `stddev` methods of
        `predictive_distribution`.

    Returns:
      Upper confidence bound at index points implied by
      `predictive_distribution` (or overridden in `**kwargs`).
    """
    ...
  


def normal_upper_confidence_bound(mean, stddev, exploration=...):
  """Normal distribution upper confidence bound.

  Args:
    mean: Array of predicted means. Must broadcast with `stddev`.
    stddev: Array of predicted standard deviations. Must broadcast with `mean`.
    exploration: Float parameter controlling the exploration/exploitation
      tradeoff.

  Returns:
    ucb: Array of upper confidence bound values.
  """
  ...


"""
This type stub file was generated by pyright.
"""

from tensorflow_probability.python.experimental.bayesopt.acquisition import acquisition_function

"""Weighted Power/Chebyshev Scalarization."""
class WeightedPowerScalarization(acquisition_function.AcquisitionFunction):
  """Weighted power scalarization acquisition function.

  Given a multi-task distribution over `T` tasks, the weighted power
  scalarization acquisition function computes

  `(sum_t w_t |a_t(x)|^p)^(1/p)`

  where:
    * `a_t` are the list of `acquisition_function_classes`.
    * `w_t` are `weights`.
    * `p` is `power`.

  By default `p` is `None` which corresponds to a value of `inf`. This is
  Chebyshev scalarization: `max w_t |a_t(x)|`, and for non `inf` `p` corresponds
  to weighted power scalarization.

  #### Examples

  Build and evaluate a Weighted Power Scalarization acquisition function.

  ```python
  import numpy as np
  import tensorflow_probability as tfp

  tfpk = tfp.math.psd_kernels
  tfpke = tfp.experimental.psd_kernels
  tfde = tfp.experimental.distributions
  tfp_acq = tfp.experimental.bayesopt.acquisition

  kernel = tfpk.ExponentiatedQuadratic()
  mt_kernel = tfpke.Independent(base_kernel=kernel, num_tasks=4)

  # Sample 10 20-dimensional index points and associated 4-dimensional
  # observations.
  index_points = np.random.uniform(size=[10, 20])
  observations = np.random.uniform(size=[10, 4])

  # Build a multitask GP.
  dist = tfde.MultiTaskGaussianProcessRegressionModel(
      kernel=mt_kernel,
      observation_index_points=index_points,
      observations,
      observation_noise_variance=1e-4)

  # Choose weights and acquisition functions for each task.
  weights = np.array([0.8, 1., 1.1, 0.5])
  acquisition_function_classes = [
      tfp_acq.GaussianProcessExpectedImprovement,
      tfp_acq.GaussianProcessUpperConfidenceBound,
      tfp_acq.GaussianProcessExpectedImprovement,
      tfp_acq.GaussianProcessUpperConfidenceBound]

  # Build the acquisition function.
  cheb_scalar_fn = tfp_acq.WeightedPowerScalarization(
      predictive_distribution=dist,
      acquisition_function_classes=acquisition_function_classes,
      observations=observations,
      weights=weights)

  # Evaluate the acquisition function on 6 predictive index points. Note that
  # `index_points` must be passed as a keyword arg.
  pred_index_points = np.random.uniform(size=[6, 20])
  acq_fn_vals = cheb_scalar_fn(index_points=pred_index_points)
  ```

  """
  def __init__(self, predictive_distribution, observations, seed=..., acquisition_function_classes=..., acquisition_kwargs_list=..., power=..., weights=...) -> None:
    r"""Construct a weighted power scalarization acquisition function.

    Args:
      predictive_distribution: `tfd.Distribution`-like, the distribution over
        observations at a set of index points (expected to be a
        `tfd.MultiTaskGaussianProcess` or
        `tfd.MultiTaskGaussianProcessRegressionModel`).
      observations: `Float` `Tensor` of observed function values. Shape has the
        form `[b1, ..., bB, N, T]`, where `N` is the number of index points and
        `T` is the number of tasks (such that the event shape of
        `predictive_distribution` is `[N, T]`) and `[b1, ..., bB]` is
        broadcastable with the batch shape of `predictive_distribution`.
      seed: PRNG seed; see tfp.random.sanitize_seed for details.
      acquisition_function_classes: `Callable` acquisition function, one per
        task.
      acquisition_kwargs_list: Kwargs to pass in to acquisition function.
      power: Numpy `float`. When this is set to `None`, this corresponds to
        Chebyshev scalarization.
      weights: `Tensor` of shape `[T]` where, `T` is the number of tasks.
    """
    ...
  
  @property
  def acquisition_function_classes(self):
    ...
  
  @property
  def acquisition_kwargs_list(self): # -> None:
    ...
  
  @property
  def weights(self):
    ...
  
  @property
  def power(self):
    ...
  
  @property
  def is_parallel(self): # -> Literal[False]:
    ...
  
  def __call__(self, **kwargs):
    """Computes the weighted power scalarization.

    Args:
      **kwargs: Keyword args passed on to the `mean` and `stddev` methods of
        `predictive_distribution`.

    Returns:
      Weighted power scalarization at index points implied by
      `predictive_distribution` (or overridden in `**kwargs`).
    """
    ...
  



"""
This type stub file was generated by pyright.
"""

import tensorflow.compat.v2 as tf

"""A kernel covariance matrix LinearOperator."""
class LinearOperatorPSDKernel(tf.linalg.LinearOperator):
  """A `tf.linalg.LinearOperator` representing a kernel covariance matrix."""
  def __init__(self, kernel_fn, x1, x2=..., kernel_args=..., num_matmul_parts=..., is_non_singular=..., is_self_adjoint=..., is_positive_definite=..., is_square=..., name=...) -> None:
    """Initializes the LinearOperator.

    This object implicitly represents the covariance matrix of `x1` and `x2`
    (`x1` if `x2` not provided) under the given `kernel`. This operator assumes
    one example dimension on each set of index points, which indexes the
    corresponding axis of the matrix. All outer dimensions are considered
    batch dimensions.

    Use this to avoid materializing the full matrix for such operations as:
    - accessing diagonal (`diag_part` method)
    - accessing a [batch of] row[s] (`row` method)
    - accessing a [batch of] column[s] (`col` method)

    Use this to perform matrix-vector products on very large covariance matrices
    by chunking the covariance matrix into parts, computing just that part of
    the output, computing a part of the covariance matrix, and the matrix-vector
    product, then forgetting the partial covariance matrix. Internally, uses
    recomputed gradients to avoid retaining infeasibly-large intermediate
    activations.

    Args:
      kernel_fn: A Python callable which takes `*kernel_args` and returns an
        instance of `tfp.math.psd_kernels.PositiveSemidefiniteKernel`. As a
        convenience, an instance may be passed instead of a function, but in
        this case gradients to kernel hyperparameters will not be available when
        using `num_matmul_parts`, and `kernel_args` must be `None`.
      x1: A floating point `Tensor`, the row index points.
      x2: Optional, a floating point `Tensor`, the column index points. If not
        provided, uses `x1`.
      kernel_args: A tuple of arguments (which may themselves be `tf.nest`
        compatible structures) to be passed to `kernel_fn`. This argument
        identifies the set of tensors which will have gradients in a
        `num_matmul_parts`-chunked matmul/backprop.
      num_matmul_parts: An optional Python `int` specifying the number of
        partitions into which the matrix should be broken when applying this
        linear operator. (An extra remainder partition is implied for uneven
        partitioning.) Because the use-case is avoiding a memory blowup, the
        partitioned matmul uses `parallel_iterations=1` and `back_prop=False`.
      is_non_singular:  Expect that this operator is non-singular.
      is_self_adjoint:  Expect that this operator is equal to its hermitian
        transpose.  If `dtype` is real, this is equivalent to being symmetric.
      is_positive_definite:  Expect that this operator is positive definite,
        meaning the quadratic form `x^H A x` has positive real part for all
        nonzero `x`.  Note that we do not require the operator to be
        self-adjoint to be positive-definite.  See:
        https://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices
      is_square:  Expect that this operator acts like square [batch] matrices.
      name: Optional name for related ops.
    """
    ...
  
  @property
  def kernel_fn(self): # -> Callable[[], Any] | Callable[..., object]:
    ...
  
  @property
  def kernel_args(self):
    ...
  
  @property
  def x1(self):
    ...
  
  @property
  def x2(self):
    ...
  
  def row(self, index):
    """Gets a row from the dense operator.

    Args:
      index: The index (indices) of the row[s] to get, may be scalar or up to
        batch shape. Suggest int64 dtype if using with GPU.

    Returns:
      rows: Row[s] of the matrix, with shape `(...batch_shape..., num_cols)`.
        Effectively the same as `operator.to_dense()[..., index, :]` for a
        scalar `index`, analogous to gather for non-scalar.
    """
    ...
  
  def col(self, index):
    """Gets a column from the dense operator.

    Args:
      index: The index (indices) of the column[s] to get, may be scalar or up to
        batch shape. Suggest int64 dtype if using with GPU.

    Returns:
      cols: Column[s] of the matrix, with shape `(...batch_shape..., num_rows)`.
        Effectively the same as `operator.to_dense()[..., index]` for a scalar
        `index`, analogous to gather for non-scalar.
    """
    ...
  



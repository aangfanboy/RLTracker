"""
This type stub file was generated by pyright.
"""

import tensorflow.compat.v2 as tf

"""A kernel covariance matrix LinearOperator with structured interpolation."""
__all__ = ['LinearOperatorInterpolatedPSDKernel']
USE_EXACT_DIAG = ...
class LinearOperatorInterpolatedPSDKernel(tf.linalg.LinearOperator):
  """Structured interpolation to approximate a large matrix.

  This implements a component of the Structured Kernel Interpolation [1]
  algorithm. We approximate the pairwise `kernel` values for two inputs `x1`,
  `x2` with the following product:

  ```none
  k(x1, x2) = r(x1) @ k(u, u) @ r(x2)^T
  ```

  where `u` is a set of points regularly spaced on grid and `r` is an
  interpolation matrix. In short, instead of evaluating `kernel` on `x1` and
  `x2`, we evaluate it on `u`, which is chosen to contain fewer points than `x1`
  and `x2` and the interpolate using the interpolation matrix.

  This construction lets us compute matrix products efficiently. If `x1`/`x2`
  are of shape `O(n)` and `u` is of shape `O(m)`, this reduces the compute cost
  and memory to `O(n + m^2)` from `O(n^2)`.

  In practice, the interpolation matrix is implicitly defined using `interp_fn`,
  of which `tfp.math.batch_interp_regular_nd_grid` linear interpolation is a
  prototypical example. When `x1 == x2` we can relatively cheaply compute the
  diagonal of that matrix exactly, to preserve positive-semi-definiteness.

  Since we rely on a dense grid `u`, this method works best when the the kernel
  inputs are low dimensional (2 or 3).

  #### References

  [1]: Wilson, A. G., & Nickisch, H. Kernel Interpolation for Scalable
       Structured Gaussian Processes (KISS-GP). 2005. arXiv.
       http://arxiv.org/abs/1503.01057

  """
  def __init__(self, kernel, bounds_min, bounds_max, num_interpolation_points, x1, x2=..., interp_fn=..., diag_shift=..., is_non_singular=..., is_self_adjoint=..., is_positive_definite=..., is_square=..., name=...) -> None:
    """Initializes the linear operator.

    `x1`, `kernel`, `x2` and `diag_shift` must broadcast to a shared batch
    dimension
    `[B]`. The overall shape of the operator will be `[B] + [R, C]`, given `x1`
    and `x2` with shapes `[B, R, D]` and `[B, C, D]` respectively.

    Args:
      kernel: Instance of `tfp.math.psd_kernels.PositiveSemidefiniteKernel'.
        Must have `feature_ndims == 1`.
      bounds_min: Floating point `Tensor`. Minimum bounds of the interpolation
        grid. Shape: [D]
      bounds_max: Floating point `Tensor`. Maximum bounds of the interpolation
        grid. Shape: [D]
      num_interpolation_points: Python integer. Number of inducing points per
        dimension.
      x1: Floating point `Tensor`. First input to the kernel. Shape: [B, R, D]
      x2: Optional floating point `Tensor`. Second input to the kernel. Shape:
        [B, C, D] Omit this argument to statically indicate that this operator
        is square, self-adjoint, positive definite and non-singular.
      interp_fn: Interpolation function with an API same as
        `tfp.math.batch_interp_regular_nd_grid`. This must implicitly define a
        matrix as in the class docstring, i.e. it must be linear in the value of
        the `y_ref` argument.
      diag_shift: Optional floating point `Tensor`. A diagonal offset to add to
        the resultant matrix. Must be `None` if the operator is not square and
        self-adjoint. Shape: [B]
      is_non_singular:  Expect that this operator is non-singular.
      is_self_adjoint:  Expect that this operator is equal to its hermitian
        transpose.  If `dtype` is real, this is equivalent to being symmetric.
      is_positive_definite:  Expect that this operator is positive definite,
        meaning the quadratic form `x^H A x` has positive real part for all
        nonzero `x`.
      is_square:  Expect that this operator acts like square [B] matrices.
      name: Name of the operator. Default: LinearOperatorInterpolatedPSDKernel
    """
    ...
  
  @property
  def kernel(self): # -> Any:
    ...
  
  @property
  def bounds_min(self):
    ...
  
  @property
  def bounds_max(self):
    ...
  
  @property
  def num_interpolation_points(self): # -> Any:
    ...
  
  @property
  def x1(self):
    ...
  
  @property
  def x2(self):
    ...
  
  @property
  def diag_shift(self):
    ...
  
  def row(self, index):
    """Gets a row from the dense operator.

    Args:
      index: The index (indices) of the row[s] to get, may be scalar or up to
        batch shape.

    Returns:
      rows: Row[s] of the matrix, with shape `(...batch_shape..., num_cols)`.
        Effectively the same as `operator.to_dense()[..., index, :]` for a
        scalar `index`, analogous to gather for non-scalar.
    """
    ...
  



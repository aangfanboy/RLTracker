"""
This type stub file was generated by pyright.
"""

import collections
from tensorflow_probability.python.experimental.mcmc import reducer as reducer_base
from tensorflow_probability.python.mcmc.internal import util as mcmc_util

"""TracingReducer for pre-packaged accumulation of samples."""
__all__ = ['TracingReducer']
class TracingState(mcmc_util.PrettyNamedTupleMixin, collections.namedtuple('TracingState', ['num_samples', 'trace_state'])):
  __slots__ = ...


class TracingReducer(reducer_base.Reducer):
  """`Reducer` that accumulates trace results at each sample.

  Trace results are defined by an appropriate `trace_fn`, which accepts the
  current chain state and kernel results, and returns the desired result.
  At each sample, the traced values are added to a `TensorArray` which
  accumulates all results. By default, all kernel results are traced but in the
  future the default will be changed to no results being traced, so plan
  accordingly.

  If wrapped in a `tfp.experimental.mcmc.WithReductions` Transition Kernel,
  TracingReducer will not accumulate the kernel results of `WithReductions`.
  Rather, the top level kernel results will be that of `WithReductions`' inner
  kernel.

  As with all reducers, `TracingReducer` does not hold state information;
  rather, it stores supplied metadata. Intermediate calculations are held in
  a `TracingState` named tuple, which is returned via `initialize` and
  `one_step` method calls.
  """
  def __init__(self, trace_fn=..., size=..., name=...) -> None:
    """Instantiates this object.

    TracingReducer can accumulate samples in a dynamic or static shape
    `TensorArray`. Specifying the `size` at instantiation will cause all
    subsequent state objects to hold a `TensorArray` of the same static size.
    If `size` is `None`, all `TensorArray`s will have dynamic size.

    Args:
      trace_fn: A callable that takes in the current chain state and the
        previous kernel results and return a `Tensor` or a nested collection
        of `Tensor`s that is accumulated across samples.
      size: Integer or scalar `Tensor` denoting the size of the accumulated
        `TensorArray`. If this is `None` (which is the default), a
        dynamic-shaped `TensorArray` will be used.
      name: Python `str` name prefixed to Ops created by this function.
        Default value: `None` (i.e., 'tracing_reducer').
    """
    ...
  
  def initialize(self, initial_chain_state, initial_kernel_results=...): # -> TracingState:
    """Initializes a `TracingState` using previously defined metadata.

    Both the `initial_chain_state` and `initial_kernel_results` do not count
    as a sample, and hence, will not be traced. This is a deliberate decision
    that ensures consistency across sampling procedures.

    Args:
      initial_chain_state: A (possibly nested) structure of `Tensor`s or Python
        `list`s of `Tensor`s representing the current state(s) of the Markov
        chain(s). It is used to infer the structure of future trace results.
      initial_kernel_results: A (possibly nested) structure of `Tensor`s
        representing internal calculations made in a related `TransitionKernel`.
        It is used to infer the structure of future trace results.

    Returns:
      state: `TracingState` with an empty `TensorArray` in its `trace_state`
        field.
    """
    ...
  
  def one_step(self, new_chain_state, current_reducer_state, previous_kernel_results): # -> TracingState:
    """Update the `current_reducer_state` with a new trace result.

    The trace result will be computed by evaluating the `trace_fn` provided
    at instantiation with the `new_chain_state` and `previous_kernel_results`.

    Args:
      new_chain_state: A (possibly nested) structure of incoming chain state(s)
        with shape and dtype compatible with those used to initialize the
        `TracingState`.
      current_reducer_state: `TracingState`s representing all previously traced
        results.
      previous_kernel_results: A (possibly nested) structure of `Tensor`s
        representing internal calculations made in a related
        `TransitionKernel`.

    Returns:
      new_reducer_state: `TracingState` with updated trace. Its `trace_state`
        field holds a `TensorArray` that includes the newly computed trace
        result.
    """
    ...
  
  def finalize(self, final_reducer_state):
    """Finalizes tracing by stacking the accumulated `TensorArray`.

    Args:
      final_reducer_state: `TracingState` that holds all desired traced results.

    Returns:
      trace: `Tensor` that represents stacked tracing results.
    """
    ...
  
  @property
  def name(self): # -> str:
    ...
  
  @property
  def trace_fn(self): # -> str:
    ...
  
  @property
  def size(self): # -> str:
    ...
  
  @property
  def parameters(self): # -> dict[str, Any | str]:
    ...
  



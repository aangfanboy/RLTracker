"""
This type stub file was generated by pyright.
"""

import collections
from tensorflow_probability.python.mcmc import kernel as kernel_base
from tensorflow_probability.python.mcmc.internal import util as mcmc_util

"""DiagonalMassMatrixAdaptation TransitionKernel."""
__all__ = ['DiagonalMassMatrixAdaptation']
def hmc_like_momentum_distribution_setter_fn(kernel_results, new_distribution):
  """Setter for `momentum_distribution` so it can be adapted."""
  ...

def hmc_like_momentum_distribution_getter_fn(kernel_results):
  """Getter for `momentum_distribution` so it can be updated."""
  ...

class DiagonalMassMatrixAdaptationResults(mcmc_util.PrettyNamedTupleMixin, collections.namedtuple('DiagonalMassMatrixAdaptationResults', ['inner_results', 'running_variance', 'step', 'num_estimation_steps'])):
  """Results of the DiagonalMassMatrixAdaptation TransitionKernel.

  Attributes:
    inner_results: Results of the inner kernel.
    running_variance: (List of) instance(s) of
      `tfp.experimental.stats.RunningVariance`, used to set
      the diagonal covariance of the momentum distribution.
    step: Int32 scalar `Tensor`. The current step number as perceived by this
      kernel. Increases by 1 for every call to `one_step`.
    num_estimation_steps: Scalar `int` `Tensor` number of initial steps to
      during which to adjust the running variance. When
      ``step == num_estimation_steps``, the momentum distribution will be
      updated and pushed into the `inner_results`.
  """
  __slots__ = ...


class DiagonalMassMatrixAdaptation(kernel_base.TransitionKernel):
  """Adapts the inner kernel's `momentum_distribution` to estimated variance.

  This kernel uses an online variance estimate to adjust a diagonal covariance
  matrix for each of the state parts. More specifically, the
  `momentum_distribution` of the innermost kernel is set to a diagonal
  multivariate normal distribution whose variance is the *inverse* of the
  online estimate. The inverse of the covariance of the momentum is often called
  the "mass matrix" in the context of Hamiltonian Monte Carlo.

  This preconditioning scheme works well when the covariance is diagonally
  dominant, and may give reasonable results even when the number of draws is
  less than the dimension. In particular, it should generally do a better job
  than no preconditioning, which implicitly uses an identity mass matrix.

  Note that this kernel does not implement a calibrated sampler; rather, it is
  intended to be used as one step of an iterative adaptation process. It
  should not be used when drawing actual samples.
  """
  def __init__(self, inner_kernel, initial_running_variance, num_estimation_steps=..., momentum_distribution_setter_fn=..., momentum_distribution_getter_fn=..., validate_args=..., experimental_shard_axis_names=..., name=...) -> None:
    """Creates the diagonal mass matrix adaptation kernel.

    Users must provide an `initial_running_variance`, either from a previous
    `DiagonalMassMatrixAdaptation`, or some other source. See
    `RunningCovariance.from_stats` for a convenient way to construct these.


    Args:
      inner_kernel: `TransitionKernel`-like object.
      initial_running_variance:
        `tfp.experimental.stats.RunningVariance`-like object, or list of them,
        for a batch of momentum distributions. These use `update` on the state
        to maintain an estimate of the variance, and so space, and so must have
        a structure compatible with the state space.
      num_estimation_steps: An optional scalar `int` `Tensor` number of initial
        steps to during which to adjust the running variance. This may be
        greater, less than, or equal to the number of burnin steps. If this
        argument is None, the mass matrix will be updated at each `one_step`
        call. Otherwise, the mass matrix will be updated when the current step
        is equal to `num_estimation_steps`.
      momentum_distribution_setter_fn: A callable with the signature
        `(kernel_results, new_momentum_distribution) -> new_kernel_results`
        where `kernel_results` are the results of the `inner_kernel`,
        `new_momentum_distribution` is a `CompositeTensor` or a nested
        collection of `CompositeTensor`s, and `new_kernel_results` are a
        possibly-modified copy of `kernel_results`. The default,
        `hmc_like_momentum_distribution_setter_fn`, presumes HMC-style
        `kernel_results`, and sets the `momentum_distribution` only under the
        `accepted_results` field.
      momentum_distribution_getter_fn: A callable with the signature
        `kernel_results -> momentum_distribution`
        where `kernel_results` are the results of the `inner_kernel` and
        `momentum_distribution` is a `CompositeTensor` or a nested
        collection of `CompositeTensor`s. The default,
        `hmc_like_momentum_distribution_getter_fn`, presumes HMC-style
        `kernel_results`, and gets the `momentum_distribution` only under the
        `accepted_results` field.
      validate_args: Python `bool`. When `True` kernel parameters are checked
        for validity. When `False` invalid inputs may silently render incorrect
        outputs.
      experimental_shard_axis_names: An optional structure of string names
        indicating how members of the state are sharded.
      name: Python `str` name prefixed to Ops created by this class. Default:
        'diagonal_mass_matrix_adaptation'.
    """
    ...
  
  @property
  def inner_kernel(self): # -> None:
    ...
  
  @property
  def name(self): # -> None:
    ...
  
  @property
  def initial_running_variance(self): # -> None:
    ...
  
  @property
  def num_estimation_steps(self): # -> None:
    ...
  
  def momentum_distribution_getter_fn(self, kernel_results):
    ...
  
  def momentum_distribution_setter_fn(self, kernel_results, new_momentum_distribution):
    ...
  
  @property
  def parameters(self): # -> dict[str, Any | None]:
    """Return `dict` of ``__init__`` arguments and their values."""
    ...
  
  def one_step(self, current_state, previous_kernel_results, seed=...): # -> tuple[Any, Any]:
    ...
  
  def bootstrap_results(self, init_state): # -> DiagonalMassMatrixAdaptationResults:
    ...
  
  @property
  def is_calibrated(self): # -> Literal[False]:
    ...
  
  @property
  def experimental_shard_axis_names(self): # -> None:
    ...
  
  def experimental_with_shard_axes(self, shard_axis_names):
    ...
  



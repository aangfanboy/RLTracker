"""
This type stub file was generated by pyright.
"""

"""Type inference pass on functional control flow graph.

Until converged, we propagate type information (dtype and shape) from inputs
toward outputs.
"""
__all__ = ['infer_types', 'infer_types_from_signature', 'is_inferring', 'signature', 'type_of_pattern']
log_debug = ...
def type_of_pattern(val, backend, preferred_type=...): # -> Any:
  """Returns the `instructions.Type` of `val`.

  Args:
    val: Pattern of backend-specific `Tensor`s or a Python or numpy constant.
    backend: Object implementing required backend operations.
    preferred_type: `instructions.Type` to prefer, if `t` is a constant.

  Returns:
    vm_type: Pattern of `instructions.TensorType` describing `t`
  """
  ...

_inferring = ...
def is_inferring(): # -> bool:
  """Returns whether type inference is running.

  This can be useful for writing special primitives that change their behavior
  depending on whether they are being inferred, staged (see
  `virtual_machine.is_staging`), or neither (i.e., dry-run execution, see
  `frontend.Context.batch`).

  Returns:
    inferring: Python `bool`, `True` if this is called in the dynamic scope of
      type inference, otherwise `False`.
  """
  ...

def infer_types(program, inputs, backend):
  """Infers the variable types of a given program.

  Args:
    program: `instructions.Program` whose types to infer.
    inputs: A `list` of backend-compatible tensors aligned with
      `program.vars_in`.
    backend: Backend implementation.

  Returns:
    typed: `instructions.Program` with types inferred.

  Raises:
    ValueError: If some types still remain incomplete after inference.
  """
  ...

def infer_types_from_signature(program, sig, backend):
  """Infers the variable types of a given program.

  Args:
    program: `instructions.Program` whose types to infer.
    sig: A `list` of (patterns of) `instructions.TensorType` aligned with
      `program.vars_in`.
    backend: Backend implementation.

  Returns:
    typed: `instructions.Program` with types inferred.

  Raises:
    ValueError: If some types still remain incomplete after inference.
  """
  ...

def signature(program, inputs, backend): # -> list[TensorType | Any]:
  """Computes a type signature for the given `inputs`.

  Args:
    program: `instructions.Program` for whose inputs to compute the signature.
    inputs: A `list` of backend-compatible tensors aligned with
      `program.vars_in`.
    backend: Backend implementation.

  Returns:
    sig: A `list` of (patterns of) `instructions.TensorType` aligned with
      `program.vars_in`.
  """
  ...


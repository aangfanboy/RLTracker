"""
This type stub file was generated by pyright.
"""

import collections
from tensorflow_probability.python.distributions import joint_distribution_coroutine

"""Joint Distribution Layers."""
__all__ = ['Affine', 'AffineLayer', 'Conv2D', 'Lambda', 'make_conv2d_layer_class', 'make_lambda_layer_class', 'Sequential', 'SequentialLayer']
Root = joint_distribution_coroutine.JointDistributionCoroutine.Root
class AffineLayer(collections.namedtuple('AffineLayer', ['weights', 'bias'])):
  """Affine layer.

  This represents a linear map: `y = weights @ x + bias`.

  Attributes:
    weights: A floating point Tensor with shape `[out_units, in_units]`.
    bias: A floating point Tensor with shape `[out_units]`.
  """
  __slots__ = ...
  def __call__(self, x):
    """Applies the layer to an input.

    Args:
      x: A floating point Tensor with shape [in_units].

    Returns:
      y: A floating point Tensor with shape [out_units].
    """
    ...
  


class Affine(joint_distribution_coroutine.JointDistributionCoroutine):
  """Distribution over affine transformations.

  By default, the distribution is effected by placing isotropic Gaussian priors
  over the `weights` and `bias` in this transformation: `y = weights @ x +
  bias`.

  #### Example

  ```python
  layer_dist = Affine(in_units=5, out_units=10)
  layer = layer_dist.sample(seed=tfp.random.sanitize_seed(0))
  y = layer(x)
  ```

  """
  def __init__(self, out_units, in_units, dtype=..., params_model_fn=..., name=...) -> None:
    """Initialize the `Affine` distribution.

    Args:
      out_units: Integer Tensor. Number of output units.
      in_units: Integer Tensor. Number of input units.
      dtype: Dtype to use for the inner distributions.
      params_model_fn: Callable with signature `(out_units, in_units, dtype) ->
        model_fn`. A model functions (in the `JointDistributionCoroutine` sense)
        used to define the `weights` and `bias` random variables.
      name: Name to use for the ops defined by this distribution.
    """
    ...
  


def make_conv2d_layer_class(strides, padding): # -> type[Conv2DLayer]:
  """Creates a `Conv2DLayer` class.

  Args:
    strides: A 2-tuple of positive integers. Strides for the spatial dimensions.
    padding: A Python string. Can be either 'SAME' or 'VALID'.

  Returns:
    conv2d_layer_class: A new `Conv2DLayer` class that closes over the args to
      this function.
  """
  class Conv2DLayer(collections.namedtuple('Conv2DLayer', ['kernel'])):
    """2-dimensional convolution (in the standard deep learning sense) layer.

    See `tf.nn.conv` for the mathematical details of what this does.

    Attributes:
      kernel: A floating point Tensor with shape `[width, height, in_channels,
        out_channels]`.
    """
    ...
  
  

class Conv2D(joint_distribution_coroutine.JointDistributionCoroutine):
  """Distribution over convolutions.

  By default, the distribution is effected by placing isotropic Gaussian prior
  over the `kernel`.

  #### Example

  ```python
  layer_dist = Conv2D(in_channels=5, out_channels=10, size=5)
  layer = layer_dist.sample(seed=tfp.random.sanitize_seed(0))
  y = layer(x)
  ```

  """
  def __init__(self, out_channels, size, in_channels, dtype=..., params_model_fn=..., strides=..., padding=..., name=...) -> None:
    """Initialize the `Conv2D` distribution.

    Args:
      out_channels: Integer Tensor. Number of output channels.
      size: Integer Tensor or a pair of integer-Tensors. Spatial extent of the
        kernel. If a single value is provided, it is used for both width and
        height.
      in_channels: Integer Tensor. Number of input channels.
      dtype: Dtype to use for the inner distribution.
      params_model_fn: Callable with signature `(out_channels, size,
        in_channels, dtype) -> model_fn`. A model functions (in the
        `JointDistributionCoroutine` sense) used to define the `kernel` random
        variable.
      strides: A 2-tuple of positive integers. Strides for the spatial
        dimensions.
      padding: A Python string. Can be either 'SAME' or 'VALID'.
      name: Name to use for the ops defined by this distribution.
    """
    ...
  


def make_lambda_layer_class(fn): # -> type[LambdaLayer]:
  """Creates a `LambdaLayer` class.

  Args:
    fn: A callable.

  Returns:
    lambda_layer_class: A new `LambdaLayer` class that closes over `fn`.
  """
  class LambdaLayer(collections.namedtuple('LambdaLayer', ['dummy_value'])):
    """Lambda layer.

    This layer applies a callable over its input.
    """
    ...
  
  

class Lambda(joint_distribution_coroutine.JointDistributionCoroutine):
  """Distribution over callable atoms.

  This can be thought of as a `tfd.VectorDeterministic` over a point in a
  0-dimensional space, where the singular event happens to be callable.

  #### Example

  ```python
  dist = Lambda(tf.square)
  layer = layer_dist.sample(seed=tfp.random.sanitize_seed(0))
  y = layer(x)  # Same as tf.square(x)
  ```

  """
  def __init__(self, fn, dtype=..., name=...) -> None:
    """Construct the `Lambda` distribution.

    Args:
      fn: Callable.
      dtype: Dtype of the zero-sized dummy tensor used to convey batch
        information.
      name: Name to use for the ops defined by this distribution.
    """
    ...
  


class SequentialLayer(collections.namedtuple('SequentialLayer', ['layers'])):
  """Sequential application of multiple layers.

  Attributes:
    layers: A sequence of layers to apply in sequence.
  """
  def __call__(self, x):
    ...
  


class Sequential(joint_distribution_coroutine.JointDistributionCoroutine):
  """Sequential layer distribution.

  ### Example

  ```python
  network = Sequential(
    Affine(4, 3),
    tf.nn.softplus,
  )
  y = network(x)
  ```
  """
  def __init__(self, *layers, name=...) -> None:
    """Construct the `Sequential`.

    For convenience, callable non-distribution layers are wrapped in the
    `Lambda` layer distribution.

    Args:
      *layers: Layer distributions to apply in sequence.
      name: Name to use for the ops defined by this distribution.
    """
    ...
  
  @property
  def layers(self): # -> tuple[Any, ...]:
    ...
  



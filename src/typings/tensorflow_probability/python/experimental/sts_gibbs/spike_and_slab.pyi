"""
This type stub file was generated by pyright.
"""

import collections
from tensorflow_probability.python.distributions import inverse_gamma
from tensorflow_probability.python.experimental.distributions.mvn_precision_factor_linop import MultivariateNormalPrecisionFactorLinearOperator

"""Sampler for sparse regression with spike-and-slab prior."""
__all__ = ['SpikeSlabSampler']
class InverseGammaWithSampleUpperBound(inverse_gamma.InverseGamma):
  """Inverse gamma distribution with an upper bound on sampled values."""
  def __init__(self, concentration, scale, upper_bound, **kwargs) -> None:
    ...
  


class MVNPrecisionFactorHardZeros(MultivariateNormalPrecisionFactorLinearOperator):
  """Multivariate normal that forces some sample dimensions to zero.

  This is equivalent to setting `loc[d] = 0.` and `precision_factor[d, d]=`inf`
  in the zeroed dimensions, but is numerically better behaved.
  """
  def __init__(self, loc, precision_factor, nonzeros, **kwargs) -> None:
    ...
  


class SpikeSlabSamplerState(collections.namedtuple('SpikeSlabSamplerState', ['x_transpose_y', 'nonzeros', 'conditional_prior_precision_chol', 'conditional_posterior_precision_chol', 'conditional_weights_mean', 'weights_posterior_precision', 'observation_noise_variance_posterior_scale', 'unnormalized_log_prob'])):
  """Quantities maintained during a sweep of the spike and slab sampler.

    This state is generated and consumed by internal sampler methods. It is not
    intended to be publicly exposed.

    Elements:
      x_transpose_y: (batch of) float `Tensor`(s) of shape `[num_features]`,
        encoding the current regression targets. Equal to
        `matvec(design_matrix, targets, adjoint_a=True)`. Note that this is
        does not depend on the sparsity pattern and so is constant during a
        given sweep.
      nonzeros: (batch of) boolean `Tensor`(s) of shape `[num_features]`
        indicating the current sparsity pattern (`gamma` in [1]). A value of
        `True` indicates that the corresponding feature has nonzero weight.
      conditional_prior_precision_chol: (batch of) float `Tensor`(s) of shape
        `[num_features, num_features]`, giving the Cholesky factor of the
        prior precision matrix 'restricted' to the current nonzero weights
        (`Omega_gamma^{-1}` in [1]). Note that the matrix shape does not vary
        with the sparsity pattern; the restriction is implemented by replacing
        the unused entries by the identity matrix (see `_select_nonzero_block`).
      conditional_posterior_precision_chol: (batch of) float `Tensor`(s) of
        shape `[num_features, num_features]`, giving the Cholesky factor of the
        posterior precision matrix restricted to the current nonzero weights
        (`V_gamma^{-1}` in [1]). Note that the matrix shape does not vary with
        the sparsity pattern; the restriction is implemented by replacing the
        unused entries by the identity matrix (see `_select_nonzero_block`).
      conditional_posterior_mean: (batch of) float `Tensor`(s) of shape
        `[num_features]`, giving the posterior mean weight vector (`beta_gamma`
        in [1]). This has nonzero values in locations where `nonzeros` is True,
        and zeros elsewhere.
      weights_posterior_precision: (batch of) float `Tensor`(s) of shape
        `[num_features]`. This may optionally vary with the observation noise,
        so is stored in the state, rather than the class. (`V^-1` in [1])
        sampled posterior (`SS_gamma / 2` in [1]).
      observation_noise_variance_posterior_scale: (batch of) scalar float
        `Tensor`s representing the scale parameter of the inverse gamma
        posterior on the observation noise variance (`SS_gamma / 2` in [1]).
        Note that the concentration parameter is fixed given `num_outputs` and
        so does not appear in the sampler state.
      unnormalized_log_prob: (batch of) scale float `Tensor`(s) score for
        the sparsity pattern represented by this state (eqn (8) in [1]).

    All quantities in the state tuple may have batch dimensions, which must
    be the same across all components of the tuple.

  #### References

  [1] Steven L. Scott and Hal Varian. Predicting the Present with Bayesian
      Structural Time Series. __International Journal of Mathematical Modelling
      and Numerical Optimisation 5.1-2 (2014): 4-23.__
      https://people.ischool.berkeley.edu/~hal/Papers/2013/pred-present-with-bsts.pdf
  """
  ...


class SpikeSlabSampler:
  """Sampler for Bayesian regression with a spike-and-slab prior on weights.

  This implementation follows the sampler described in section 3.2
  of Scott and Varian, 2013 [1].

  ### Model

  This sampler assumes the regression model

  ```
  y ~ Normal(loc=matvec(design_matrix,  # `X` in [1].
                        weights),       # `beta` in `[1]`.
             scale=observation_noise_scale)  # `sigma_epsilon` in [1].
  ```

  where the design matrix has shape `[num_outputs, num_features]`, with a
  conjugate InverseGamma prior on the noise variance (eqn (6) of [1]):

  ```
  observation_noise_scale**2 ~ InverseGamma(
    concentration=observation_noise_variance_prior_concentration,
    scale=observation_noise_variance_prior_scale)
  ```

  and a spike-and-slab prior on the weights (eqns (5) and (6) of [1]):

  ```
  slab_weights ~ MultivariateNormal(
     loc=0.,  # `b` from [1].
     precision=(weights_prior_precision  # `Omega^{-1}` from [1].
                / observation_noise_scale**2))
  nonzeros ~ Bernoulli(probs=nonzero_prior_prob)  # `gamma` from [1].
  weights = slab_weights * nonzeros
  ```

  ### Example

  Constructing a sampler instance specifies the model priors:

  ```python
  sampler = spike_and_slab.SpikeSlabSampler(
    design_matrix=design_matrix,
    observation_noise_variance_prior_concentration=1.,
    observation_noise_variance_prior_scale=1.
    nonzero_prior_prob=0.1)
  ```

  The sampler instance itself is stateless, though some internal methods take
  or accept `SpikeSlabSamplerState` tuples representing posterior quantities
  maintained within a sampling pass. The sampler is
  invoked by passing the regression targets (`y`) and the initial sparsity
  pattern (`nonzeros`):

  ```
  (observation_noise_variance,
   weights) = sampler.sample_noise_variance_and_weights(
     targets=y, initial_nonzeros=tf.ones([num_features], dtype=tf.bool))
  ```

  This implements the stochastic search variable selection (SSVS) algorithm [2],
  sweeping over the features in random order to resample their sparsity
  indicators one by one. It then returns a sample from the joint posterior
  on the regression weights and the observation noise variance, conditioned
  on the resampled sparsity pattern.

  #### References

  [1] Steven L. Scott and Hal Varian. Predicting the Present with Bayesian
      Structural Time Series. __International Journal of Mathematical Modelling
      and Numerical Optimisation 5.1-2 (2014): 4-23.__
      https://people.ischool.berkeley.edu/~hal/Papers/2013/pred-present-with-bsts.pdf

  [2] George, E. I. and McCulloch, R. E. Approaches for Bayesian variable
      selection. __Statistica Sinica 7, 339â€“374 (1997)__.
  """
  def __init__(self, design_matrix, nonzero_prior_prob=..., weights_prior_precision=..., default_pseudo_observations=..., observation_noise_variance_prior_concentration=..., observation_noise_variance_prior_scale=..., observation_noise_variance_upper_bound=..., num_missing=...) -> None:
    """Initializes priors for the spike and slab sampler.

    Args:
      design_matrix: (batch of) float `Tensor`(s) regression design matrix (`X`
        in [1]) having shape `[num_outputs, num_features]`.
      nonzero_prior_prob: scalar float `Tensor` prior probability of the 'slab',
        i.e., prior probability that any given feature has nonzero weight (`pi`
        in [1]). Default value: `0.5`.
      weights_prior_precision: (batch of) float `Tensor` complete prior
        precision matrix(s) over the weights, of shape `[num_features,
        num_features]`. If not specified, defaults to the Zellner g-prior
        specified in `[1]` as `Omega^{-1} = kappa * (X'X + diag(X'X)) / (2 *
        num_outputs)`, in which we've plugged in the suggested default of `w =
        0.5`. The parameter `kappa` is controlled by the
        `default_pseudo_observations` argument. Default value: `None`.
      default_pseudo_observations: scalar float `Tensor` Controls the number of
        pseudo-observations for the prior precision matrix over the weights.
        Corresponds to `kappa` in [1]. See also `weights_prior_precision`.
      observation_noise_variance_prior_concentration: scalar float `Tensor`
        concentration parameter of the inverse gamma prior on the noise
        variance. Corresponds to `nu / 2` in [1]. Default value: 0.005.
      observation_noise_variance_prior_scale: scalar float `Tensor` scale
        parameter of the inverse gamma prior on the noise variance. Corresponds
        to `ss / 2` in [1]. Default value: 0.0025.
      observation_noise_variance_upper_bound: optional scalar float `Tensor`
        maximum value of sampled observation noise variance. Specifying a bound
        can help avoid divergence when the sampler is initialized far from the
        posterior. Default value: `None`.
      num_missing: Optional scalar float `Tensor`. Corrects for how many missing
        values are are coded as zero in the design matrix.
    """
    ...
  
  def sample_noise_variance_and_weights(self, targets, initial_nonzeros, seed, previous_observation_noise_variance=...):
    """(Re)samples regression parameters under the spike-and-slab model.

    Args:
      targets: (batch of) float Tensor regression targets (y-values), of shape
        `[num_outputs]`.
      initial_nonzeros: (batch of) boolean Tensor vector(s) of shape
        `[num_features]`.
      seed: PRNG seed; see `tfp.random.sanitize_seed` for details.
      previous_observation_noise_variance: Optional float to scale the
        `weights_prior_precision`. This behavior is not recommended.

    Returns:
      observation_noise_variance: (batch of) scalar float Tensor posterior
        sample(s) of the observation noise variance, given the resampled
        sparsity pattern.
      weights: (batch of) float Tensor posterior sample(s) of the weight vector
        given the resampled sparsity pattern (encoded as zeros in the
        weight vector) *and* the sampled observation noise variance. Has
        shape `[num_features]`.
    """
    ...
  


_set_vector_index = ...

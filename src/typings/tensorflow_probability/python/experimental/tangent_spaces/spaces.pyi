"""
This type stub file was generated by pyright.
"""

"""Class definitions for tangent spaces."""
__all__ = ['AxisAlignedSpace', 'FullSpace', 'GeneralSpace', 'TangentSpace', 'UnspecifiedTangentSpaceError', 'ZeroSpace']
JAX_MODE = ...
NUMPY_MODE = ...
TF_MODE = ...
def coordinatewise_jvp(f, x): # -> None:
  """Returns the diagonal of the jacobian of an coordinatewise `f`."""
  ...

def compute_new_basis_tensor(f, x, basis):
  ...

class TangentSpace:
  """Represents a tangent space to some manifold M at a point x.

  TFP allows one to transform manifolds via `Bijector`s. Keeping track
  of the tangent space to a manifold allows us to calculate the
  correct push-forward density under such transformations.

  In general, the density correction involves computing the basis of
  the tangent space as well as the image of that basis under the
  transformation. But we can avoid this work in special cases that
  arise from the properties of the transformation f (e.g.,
  dimension-preserving, coordinate-wise) and the density p of the
  manifold (e.g., discrete, supported on all of R^n).

  Each subclass of `TangentSpace` represents a specific property of
  densities seen in the uses of TFP. The methods of `TangentSpace`
  represent the special `Bijector` structures provided by TFP. Each
  subclass thus defines how to compute the density correction under
  each kind of transformation.

  """
  def transform_general(self, x, f, **kwargs):
    """Returns the density correction, in log space, corresponding to f at x.

    Also returns a new `TangentSpace` representing the tangent to fM at f(x).

    Args:
      x: `Tensor` (structure). The point at which to calculate the density.
      f: `Bijector` or one of its subclasses. The transformation that requires a
        density correction based on this tangent space.
      **kwargs: Optional keyword arguments as part of the Bijector.

    Returns:
      log_density: A `Tensor` representing the log density correction of f at x
      space: A `TangentSpace` representing the tangent to fM at f(x)

    Raises:
      NotImplementedError: if the `TangentSpace` subclass does not implement
        this method.
    """
    ...
  
  def transform_dimension_preserving(self, x, f, **kwargs):
    """Same as `transform_general`, assuming f goes from R^n to R^n.

    Default falls back to `transform_general`, which may be overridden
    in subclasses.

    Args:
      x: same as in `transform_general`.
      f: same as in `transform_general`.
      **kwargs: same as in `transform_general`.

    Returns:
      log_density: A `Tensor` representing the log density correction of f at x
      space: A `TangentSpace` representing the tangent to fM at f(x)

    Raises:
      NotImplementedError: if the `TangentSpace` subclass does not implement
        `transform_general`.

    """
    ...
  
  def transform_projection(self, x, f, **kwargs):
    """Same as `transform_general`, with f a projection (or its inverse).

    Default falls back to `transform_general`, which may be overridden
    in subclasses.

    Args:
      x: same as in `transform_general`.
      f: same as in `transform_general`.
      **kwargs: same as in `transform_general`.

    Returns:
      log_density: A `Tensor` representing the log density correction of f at x
      space: A `TangentSpace` representing the tangent to fM at f(x)

    Raises:
      NotImplementedError: if the `TangentSpace` subclass does not implement
        `transform_general`.
    """
    ...
  
  def transform_coordinatewise(self, x, f, **kwargs):
    """Same as `transform_dimension_preserving`, for a coordinatewise f.

    Default falls back to `transform_dimension_preserving`, which may
    be overridden in subclasses.

    Args:
      x: same as in `transform_dimension_preserving`.
      f: same as in `transform_dimension_preserving`.
      **kwargs: same as in `transform_dimension_preserving`.

    Returns:
      log_density: A `Tensor` representing the log density correction of f at x
      space: A `TangentSpace` representing the tangent to fM at f(x)

    Raises:
      NotImplementedError: if the `TangentSpace` subclass does not implement
        `transform_dimension_preserving`.

    """
    ...
  


class Basis:
  """Represents the basis of a `TangentSpace`."""
  def to_dense(self):
    """Returns densified version of this Basis.

    Returns:
      Tensor of shape `[N, B1, ..., Bn, D1, ... Dk], where
      `N` is the number of bases elements, `Bi` are possible
      batch dimensions, and `Di` are the dimensions of the
      tangent space (i.e. `R^{D1 x ... x Dk}`).
    """
    ...
  
  def to_dense_matrix(self, event_ndims):
    """Returns densified version of this Basis as a matrix.

    Args:
      event_ndims: Python `int` representing the number of right most dimensions
        that are the dimensions of the tangent space.
    Returns:
      Tensor of shape `[B1, ..., Bn, N, F], where
      `N` is the number of bases elements, `Bi` are possible
      batch dimensions, and `F` are the last `event_ndims` dimensions
      reshaped as one dimension.
    """
    ...
  


class LinearOperatorBasis(Basis):
  """Basis parameterized by a `LinearOperator`."""
  def __init__(self, basis_linop) -> None:
    ...
  
  @property
  def basis_linop(self): # -> Any:
    ...
  


class DenseBasis(Basis):
  """Basis parameterized by a dense tensor."""
  def __init__(self, basis_tensor) -> None:
    ...
  


class FullUnitBasis(Basis):
  """Represents a full axis aligned unit basis."""
  def __init__(self, event_shape, dtype) -> None:
    """Initialize a basis of axis aligned unit vectors.

    Args:
      event_shape: object representing the shape of the ambient space;
        convertible to `tf.TensorShape`.
      dtype: `Dtype` of this basis.
    """
    ...
  


class FullUnitBasisOn(Basis):
  """Represents an axis aligned unit basis on a masked portion of the space."""
  def __init__(self, axis_mask) -> None:
    ...
  


class AxisAlignedSpace(TangentSpace):
  """Tangent space of M for a distribution with axis-aligned subspace support.

  This subclass covers cases where the support of the distribution is
  on an axis-aligned subspace, such as lower-triangular matrices. In
  this special case we can represent the standard basis of the
  subspace with a mask. The subclass is designed to support axis-aligned
  injections like the `FillTriangular` `Bijector`.

  Any Bijector calling the `transform_projection` method is expected
  to define an `experimental_update_live_dimensions` method.
  """
  def __init__(self, axis_mask) -> None:
    """Constructs an AxisAlignedSpace with a set of live dimensions.

    Args:
      axis_mask: `Tensor`. A bit-mask of the live dimensions of the space.
    """
    ...
  


def jacobian_determinant(x, f, **kwargs):
  ...

class FullSpace(TangentSpace):
  """Tangent space of M for distributions supported on all of R^n.

  This subclass covers full-rank distributions on n-dimensional
  manifolds. In this common case we can take the basis to be the
  standard basis for R^n, so we need not explicitly represent it
  at all.
  """
  ...


def volume_coefficient(basis):
  ...

class GeneralSpace(TangentSpace):
  """Arbitrary tangent space when no more-efficient special case applies."""
  def __init__(self, basis, computed_log_volume=...) -> None:
    """Initialize a GeneralSpace with a basis.

    Args:
      basis: `Basis` object representing a basis of shape
        `[N, B1, ..., Bk, D1, ... Dl]`, where `N` is the
        number of bases vectors, `Bi` are batch dimensions and `Di` refer to
        the dimensions that this basis lives in.
      computed_log_volume: Optional `Tensor` of shape `[B1, ..., Bk]`. Computed
        log-volume coefficient.
        Default `None`.
    """
    ...
  


class ZeroSpace(TangentSpace):
  """Tangent space of M for discrete distributions.

  In this special case the tangent space is 0-dimensional, and the
  basis is represented by a 0x0 matrix, which gives 0 as the density
  correction term.

  """
  ...


class UnspecifiedTangentSpaceError(Exception):
  """An exception raised when a tangent space has not been specified."""
  def __init__(self) -> None:
    ...
  



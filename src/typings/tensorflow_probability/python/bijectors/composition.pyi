"""
This type stub file was generated by pyright.
"""

from tensorflow_probability.python.bijectors import bijector

"""Composition base class."""
__all__ = ['Composition']
JAX_MODE = ...
def pack_structs_like(template, *structures): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
  """Converts a tuple of structs like `template` to a structure of tuples."""
  ...

def unpack_structs_like(template, packed): # -> tuple[Any | defaultdict[Any, Any] | list[Any] | None, ...]:
  """Converts a structure of tuples like `template` to a tuple of structures."""
  ...

MinEventNdimsInferenceDownstreamQuantities = ...
BijectorWithMetadata = ...
class Composition(bijector.Bijector):
  """Base class for Composition bijectors (Chain, JointMap).

  A Composition represents a partially ordered set of invertible
  transformations. These transformations may happen in series (Chain), in
  parallel (JointMap), or they could be an arbitrary DAG. Composition handles
  the common machinery of such transformations, delegating graph-traversal to
  `_walk_forward` and `_walk_inverse` (which must be overridden by subclasses).

  The `_walk_{direction}` methods take a `step_fn`, a single (structured)
  `argument` (representing zipped `*args`), and arbitrary `**kwargs`. They are
  responsible for invoking `step_fn(bij, bij_inputs, **bij_kwds)`
  for each nested bijector. See `Chain` and `JointMap` for examples.

  These methods are typically invoked using `_call_walk_{direction}`, which
  wraps `step_fn` and converts structured `*args` into a single structure of
  tuples, allowing users to provide a `step_fn` with multiple positional
  arguments (e.g., `foward_log_det_jacobian`).

  In practice, Bijector methods are defined in the base-class, and users
  should not need to invoke `walk` methods directly.
  """
  def __init__(self, bijectors, name, parameters, forward_min_event_ndims=..., inverse_min_event_ndims=..., validate_event_size=..., **kwargs) -> None:
    """Instantiates a Composition of bijectors.

    Args:
      bijectors: A nest-compatible structure of bijector instances or a
        `Composition` bijector. If `bijectors` is a nested structure, then
        `_walk_forward` and `_walk_inverse` must be implemented. If `bijectors`
        is a `Composition` bijector, `_walk_forward` and `_walk_inverse` call
        its corresponding methods.
      name: Name of this bijector.
      parameters: Dictionary of parameters used to initialize this bijector.
        These must be the exact values passed to `__init__`.
      forward_min_event_ndims: A (structure of) integers or `None` values.
        If all values are integers, then these specify the mininimum rank of
        each event part; their structure must match that of inputs to `forward`.
        If the minimum ranks are not known, inference may be triggered by
        passing a structure of `None` values instead. This structure must be
        such that calling `self._walk_forward(step_fn, forward_min_event_ndims)`
        passes exactly one `None` value to each toplevel invocation of
        `step_fn`---that is, it should correspond to the structure of
        *bijectors* that act directly on a user-passed input (excluding
        bijectors that act on downstream quantities), which may in general be
        shallower than the structure of inputs to `forward`. For example, the
        first step of a Chain applies a single bijector, so Chain would pass a
        single `None` (even though the initial bijector might itself accept a
        multipart input). On the other hand, the bijectors in a JointMap are
        all applied directly to user-passed input, so the
        appropriate structure would be that of `self.bijectors` (even if some
        of those bijectors might themselves accept multipart inputs).
      inverse_min_event_ndims: A (structure of) integers and/or `None` values,
        with semantics analogous to `forward_min_event_ndims`.
      validate_event_size: Checks that bijectors are not applied to inputs with
        incomplete support. For example, the following LDJ would be incorrect:
        `Chain([Scale(), SoftmaxCentered()]).forward_log_det_jacobian([1], [1])`
        The jacobian contribution from `Scale` applies to a 2-dimensional input,
        but the output from `SoftMaxCentered` is a 1-dimensional input embedded
        in a 2-dimensional space. Setting `validate_event_size=True` (default)
        prints warnings in these cases. When `validate_args` is also `True`, the
        warning is promoted to an exception.
      **kwargs: Additional parameters forwarded to the bijector base-class.
    """
    ...
  
  @property
  def bijectors(self):
    ...
  
  @property
  def validate_event_size(self): # -> bool:
    ...
  
  def forward_event_ndims(self, event_ndims, **kwargs): # -> tuple[Any | defaultdict[Any, Any] | list[Any] | None, ...] | defaultdict[Any, Any] | Any | list[Any] | object | None:
    ...
  
  def inverse_event_ndims(self, event_ndims, **kwargs): # -> tuple[Any | defaultdict[Any, Any] | list[Any] | None, ...] | defaultdict[Any, Any] | Any | list[Any] | object | None:
    ...
  
  def __str__(self) -> str:
    ...
  
  def __repr__(self): # -> str:
    ...
  


_update_inverse_min_event_ndims = ...

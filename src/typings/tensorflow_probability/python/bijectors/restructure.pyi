"""
This type stub file was generated by pyright.
"""

from tensorflow_probability.python.bijectors import bijector

"""Restructure Bijector."""
__all__ = ['Restructure']
def unique_token_set(source_structure): # -> set[None]:
  """Checks that structured tokens are unique, and returns the set of values."""
  ...

class Restructure(bijector.AutoCompositeTensorBijector):
  """Converts between nested structures of Tensors.

    This is useful when constructing non-trivial chains of multipart bijectors.
    It partitions inputs into different logical "blocks", which may be fed as
    arguments to downstream multipart bijectors.

    Example Usage:

      ```python

      # Pack a 3-element list of tensors into a dict. The output structure,
      # `structure_1`, is defined as a dict in which the values are list
      # indices.
      structure_1 = {'a': 1, 'b': 2, 'c': 0}
      list_to_dict = Restructure(output_structure=structure_1)
      input_list = [0.01, 0.02, 0.03]
      assert list_to_dict.forward(input_list) == {
        'a': 0.02, 'b': 0.03, 'c': 0.01}

      # Now assume that, instead of a list/tuple (the default), the input
      # structure is another dict. The output structure is the same as
      # defined above, and consecutive integers are again used to associate
      # components of the input and output structures.
      structure_2 = {'c': 2, 'd': 1, 'e': 0}
      dict_to_dict = Restructure(
        structure_1, input_structure=structure_2)
      input_dict = {'c': -3.5, 'd': 96.0, 'e': 12.0}
      assert dict_to_dict.forward(input_dict) == {
        'a': 96.0, 'b': -3.5, 'c': 12.0}

      # Restructure a dict to a namedtuple.
      Example = collections.namedtuple('Example', ['x', 'y', 'z'])
      structure_3 = Example(2, 0, 1)
      namedtuple_to_dict = Restructure(structure_3, input_structure=structure_2)
      assert namedtuple_to_dict(input_dict) == Example(x=-3.5, y=12.0, z=96.0)

      assert namedtuple_to_dict.inverse(Example(x=0.01, y=0.02, z=0.03)) == {
        'c': 0.01, 'd': 0.03, 'e': 0.02}

      # Restructure can be applied to structures of mixed type and arbitrary
      # depth:
      restructure = Restructure({
        'foo': [0, 1],
        'bar': [3, 2],
        'baz': [4, 5, 6]
      })

      # Note that x is a *python-list* of tensors.
      # To permute elements of an individual Tensor, see `tfb.Permute`.
      x = [1, 2, 4, 8, 16, 32, 64]

      assert restructure.forward(x) == {
          'foo': [1, 2],
          'bar': [8, 4],
          'baz': [16, 32, 64]
      }

      # Where Restructure is useful:
      complex_bijector = Chain([
        # Apply different transformations to each block.
        JointMap({
          'foo': ScaleMatVecLinearOperator(...),  # Operates on the full block
          'bar': ScaleMatVecLinearOperator(...),  # Operates on the full block
          'baz': [Exp(), Scale(10.), Shift(-1.)]  # Different bijectors for each
        }),
        # Group the tensor into logical blocks.
        Restructure({
          'foo': [0, 1],
          'bar': [3, 2],
          'baz': [4, 5, 6],
        }),
        # Split an input tensor into 7 chunks.
        Split([2, 4, 6, 8, 10, 12, 14])
      ])
      ```
  """
  def __init__(self, output_structure, input_structure=..., name=...) -> None:
    """Creates a `Restructure` bijector.

    Args:
      output_structure: A tf.nest-compatible structure of tokens describing the
        output of `forward` (equivalently, the input of `inverse`).
      input_structure: A tf.nest-compatible structure of tokens describing the
        input to `forward`. If unspecified, a default structure is inferred from
        `output_structure`. The default structure expects a `list` if tokens are
        integers, or a `dict` if the tokens are strings.
      name: Name of this bijector.
    Raises:
      ValueError: If tokens are duplicated, or a required default structure
        cannot be inferred.
    """
    ...
  
  def forward_event_shape(self, x_shape, **kwargs): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
    ...
  
  def inverse_event_shape(self, y_shape, **kwargs): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
    ...
  
  def forward_event_shape_tensor(self, x_shape, **kwargs): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
    ...
  
  def inverse_event_shape_tensor(self, y_shape, **kwargs): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
    ...
  
  def forward_dtype(self, x_dtype=..., **kwargs): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
    ...
  
  def inverse_dtype(self, y_dtype=..., **kwargs): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
    ...
  
  def forward_event_ndims(self, x_ndims, **kwargs): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
    ...
  
  def inverse_event_ndims(self, y_ndims, **kwargs): # -> defaultdict[Any, Any] | Any | list[Any] | object | None:
    ...
  


def tree_flatten(example, name=...):
  """Returns a Bijector variant of tf.nest.flatten.

  To make it a Bijector, it has to know how to "unflatten" as
  well---unlike the real `tf.nest.flatten`, this can only flatten or
  unflatten a specific structure.  The `example` argument defines the
  structure.

  See also the `Restructure` bijector for general rearrangements.

  Args:
    example: A Tensor or (potentially nested) collection of Tensors.
    name: An optional Python string, inserted into names of TF ops
      created by this bijector.

  Returns:
    flatten: A Bijector whose `forward` method flattens structures
      parallel to `example` into a list of Tensors, and whose
      `inverse` method packs a list of Tensors of the right length
      into a structure parallel to `example`.

  #### Example

  ```python
  x = tf.constant(1)
  example = collections.OrderedDict([
      ('a', [x, x, x]),
      ('b', x)])
  bij = tfb.tree_flatten(example)
  ys = collections.OrderedDict([
      ('a', [1, 2, 3]),
      ('b', 4.)])
  bij.forward(ys)
  # Returns [1, 2, 3, 4.]
  ```

  """
  ...

def pack_sequence_as(example, name=...): # -> Restructure:
  """Returns a Bijector variant of tf.nest.pack_sequence_as.

  See also the `Restructure` bijector for general rearrangements.

  Args:
    example: A Tensor or (potentially nested) collection of Tensors.
    name: An optional Python string, inserted into names of TF ops
      created by this bijector.

  Returns:
    pack: A Bijector whose `forward` method packs a list of Tensors of
      the right length into a structure parallel to `example`, and
      whose `inverse` method flattens structures parallel to `example`
      into a list of Tensors.

  #### Example

  ```python
  x = tf.constant(1)
  example = collections.OrderedDict([
      ('a', [x, x, x]),
      ('b', x)])
  bij = tfb.pack_sequence_as(example)
  bij.forward([1, 2, 3, 4.])

  # Returns
  # collections.OrderedDict([
  #     ('a', [1, 2, 3]),
  #     ('b', 4.)])
  ```

  """
  ...


"""
This type stub file was generated by pyright.
"""

"""Internal utility functions for implementing TransitionKernels."""
__all__ = ['choose', 'choose_from', 'enable_store_parameters_in_results', 'index_remapping_gather', 'is_list_like', 'is_namedtuple_like', 'make_name', 'maybe_call_fn_and_grads', 'prepare_state_parts', 'PrettyNamedTupleMixin', 'safe_sum', 'SEED_CTOR_ARG_DEPRECATION_MSG', 'set_doc', 'strip_seeds', 'warn_if_parameters_are_not_simple_tensors']
JAX_MODE = ...
SEED_CTOR_ARG_DEPRECATION_MSG = ...
class PrettyNamedTupleMixin:
  """Mixin adding a nicer `__repr__` for `namedtuple`s."""
  __slots__ = ...
  def __repr__(self): # -> str:
    ...
  


def prepare_state_parts(state_or_state_part, dtype=..., name=...): # -> tuple[list[Any], bool]:
  """Calls c2t on each element or the entirety if not iterable; returns list."""
  ...

def is_list_like(x): # -> bool:
  """Helper which returns `True` if input is `list`-like."""
  ...

def is_namedtuple_like(x): # -> bool:
  """Helper which returns `True` if input is `collections.namedtuple`-like."""
  ...

def make_name(super_name, default_super_name, sub_name):
  """Helper which makes a `str` name; useful for tf.name_scope."""
  ...

def choose(is_accepted, proposed, current, name=...): # -> Any:
  """Helper which expand_dims `is_accepted` then applies tf.where."""
  ...

def choose_from(n, options):
  """Helper to select the n-th option from a list of options.

  This is useful when `n` is not a concrete value. Also note that
  the value of `n` will be clipped to the edges of the interval
  `[0, len(options) - 1]`.

  Args:
    n: Scalar `int` `Tensor` option.
    options: List of options to choose from. All the options should have the
      same nested structure.

  Returns:
    The n-th option among `options`.
  """
  ...

def strip_seeds(obj): # -> Any:
  ...

def safe_sum(x, alt_value=..., name=...):
  """Elementwise adds list members, replacing non-finite results with alt_value.

  Typically the `alt_value` is chosen so the `MetropolisHastings`
  `TransitionKernel` always rejects the proposal.

  Args:
    x: Python `list` of `Tensors` to elementwise add.
    alt_value: Python scalar used to replace any elementwise sums which would
      otherwise be non-finite.
    name: Python `str` name prefixed to Ops created by this function.
      Default value: `None` (i.e., "safe_sum").

  Returns:
    safe_sum: `Tensor` representing the elementwise sum of list of `Tensor`s
      `x` or `alt_value` where sums are non-finite.

  Raises:
    TypeError: if `x` is not list-like.
    ValueError: if `x` is empty.
  """
  ...

def set_doc(value): # -> Callable[..., Any]:
  """Decorator to programmatically set a function docstring."""
  ...

def maybe_call_fn_and_grads(fn, fn_arg_list, result=..., grads=..., check_non_none_grads=..., name=...): # -> tuple[tuple[Any, Any] | Any | list[Any | None] | None, Any | list[Any] | list[Any | None] | None]:
  """Calls `fn` and computes the gradient of the result wrt `args_list`."""
  ...

def enable_store_parameters_in_results(kernel): # -> Any:
  """Enables the `store_parameters_in_results` parameter in a chain of kernels.

  This is a temporary utility for use during the transition period of the
  parameter storage methods.

  Args:
    kernel: A TransitionKernel.

  Returns:
    kernel: The same kernel, but recreated with `store_parameters_in_results`
        recursively set to `True` in its parameters and its inner kernels (as
        appropriate).
  """
  ...

def warn_if_parameters_are_not_simple_tensors(params_dict): # -> None:
  ...

def index_remapping_gather(params, indices, axis=..., indices_axis=..., name=...):
  """Gather values from `axis` of `params` using `indices_axis` of `indices`.

  The shape of `indices` must broadcast to that of `params` when
  their `indices_axis` and `axis` (respectively) are aligned:

  ```python
  # params.shape:
  [p[0],  ..., ...,         p[axis], ..., ..., p[rank(params)] - 1])
  # indices.shape:
        [i[0], ..., i[indices_axis], ..., i[rank(indices)] - 1])
  ```

  In particular, `params` must have at least as many
  leading dimensions as `indices` (`axis >= indices_axis`), and at least as many
  trailing dimensions (`rank(params) - axis >= rank(indices) - indices_axis`).

  The `result` has the same shape as `params`, except that the dimension
  of size `p[axis]` is replaced by one of size `i[indices_axis]`:

  ```python
  # result.shape:
  [p[0],  ..., ..., i[indices_axis], ..., ..., p[rank(params) - 1]]
  ```

  In the case where `rank(params) == 5`, `rank(indices) == 3`, `axis = 2`, and
  `indices_axis = 1`, the result is given by

   ```python
   # alignment is:                       v axis
   # params.shape    ==   [p[0], p[1], p[2], p[3], p[4]]
   # indices.shape   ==         [i[0], i[1], i[2]]
   #                                     ^ indices_axis
   result[i, j, k, l, m] = params[i, j, indices[j, k, l], l, m]
  ```

  Args:
    params:  `N-D` `Tensor` (`N > 0`) from which to gather values.
      Number of dimensions must be known statically.
    indices: `Tensor` with values in `{0, ..., params.shape[axis] - 1}`, whose
      shape broadcasts to that of `params` as described above.
    axis: Python `int` axis of `params` from which to gather.
    indices_axis: Python `int` axis of `indices` to align with the `axis`
      over which `params` is gathered.
    name: String name for scoping created ops.

  Returns:
    `Tensor` composed of elements of `params`.

  Raises:
    ValueError: If shape/rank requirements are not met.
  """
  ...


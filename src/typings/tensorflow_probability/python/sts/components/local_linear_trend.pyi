"""
This type stub file was generated by pyright.
"""

from tensorflow_probability.python.distributions import linear_gaussian_ssm
from tensorflow_probability.python.sts.structural_time_series import StructuralTimeSeries

"""Local Linear Trend model."""
class LocalLinearTrendStateSpaceModel(linear_gaussian_ssm.LinearGaussianStateSpaceModel):
  """State space model for a local linear trend.

    A state space model (SSM) posits a set of latent (unobserved) variables that
    evolve over time with dynamics specified by a probabilistic transition model
    `p(z[t+1] | z[t])`. At each timestep, we observe a value sampled from an
    observation model conditioned on the current state, `p(x[t] | z[t])`. The
    special case where both the transition and observation models are Gaussians
    with mean specified as a linear function of the inputs, is known as a linear
    Gaussian state space model and supports tractable exact probabilistic
    calculations; see `tfp.distributions.LinearGaussianStateSpaceModel` for
    details.

    The local linear trend model is a special case of a linear Gaussian SSM, in
    which the latent state posits a `level` and `slope`, each evolving via a
    Gaussian random walk:

    ```python
    level[t] = level[t-1] + slope[t-1] + Normal(0., level_scale)
    slope[t] = slope[t-1] + Normal(0., slope_scale)
    ```

    The latent state is the two-dimensional tuple `[level, slope]`. The
    `level` is observed at each timestep.

    The parameters `level_scale`, `slope_scale`, and `observation_noise_scale`
    are each (a batch of) scalars. The batch shape of this `Distribution` is the
    broadcast batch shape of these parameters and of the `initial_state_prior`.

    #### Mathematical Details

    The linear trend model implements a
    `tfp.distributions.LinearGaussianStateSpaceModel` with `latent_size = 2`
    and `observation_size = 1`, following the transition model:

    ```
    transition_matrix = [[1., 1.]
                         [0., 1.]]
    transition_noise ~ N(loc=0., scale=diag([level_scale, slope_scale]))
    ```

    which implements the evolution of `[level, slope]` described above, and
    the observation model:

    ```
    observation_matrix = [[1., 0.]]
    observation_noise ~ N(loc=0, scale=observation_noise_scale)
    ```

    which picks out the first latent component, i.e., the `level`, as the
    observation at each timestep.

    #### Examples

    A simple model definition:

    ```python
    linear_trend_model = LocalLinearTrendStateSpaceModel(
        num_timesteps=50,
        level_scale=0.5,
        slope_scale=0.5,
        initial_state_prior=tfd.MultivariateNormalDiag(scale_diag=[1., 1.]))

    y = linear_trend_model.sample() # y has shape [50, 1]
    lp = linear_trend_model.log_prob(y) # log_prob is scalar
    ```

    Passing additional parameter dimensions constructs a batch of models. The
    overall batch shape is the broadcast batch shape of the parameters:

    ```python
    linear_trend_model = LocalLinearTrendStateSpaceModel(
        num_timesteps=50,
        level_scale=tf.ones([10]),
        slope_scale=0.5,
        initial_state_prior=tfd.MultivariateNormalDiag(
          scale_diag=tf.ones([10, 10, 2])))

    y = linear_trend_model.sample(5) # y has shape [5, 10, 10, 50, 1]
    lp = linear_trend_model.log_prob(y) # has shape [5, 10, 10]
    ```

  """
  def __init__(self, num_timesteps, level_scale, slope_scale, initial_state_prior, observation_noise_scale=..., name=..., **linear_gaussian_ssm_kwargs) -> None:
    """Build a state space model implementing a local linear trend.

    Args:
      num_timesteps: Scalar `int` `Tensor` number of timesteps to model
        with this distribution.
      level_scale: Scalar (any additional dimensions are treated as batch
        dimensions) `float` `Tensor` indicating the standard deviation of the
        level transitions.
      slope_scale: Scalar (any additional dimensions are treated as batch
        dimensions) `float` `Tensor` indicating the standard deviation of the
        slope transitions.
      initial_state_prior: instance of `tfd.MultivariateNormal`
        representing the prior distribution on latent states; must
        have event shape `[2]`.
      observation_noise_scale: Scalar (any additional dimensions are
        treated as batch dimensions) `float` `Tensor` indicating the standard
        deviation of the observation noise.
      name: Python `str` name prefixed to ops created by this class.
        Default value: "LocalLinearTrendStateSpaceModel".
      **linear_gaussian_ssm_kwargs: Optional additional keyword arguments to
        to the base `tfd.LinearGaussianStateSpaceModel` constructor.
    """
    ...
  
  @property
  def level_scale(self):
    """Standard deviation of the level transitions."""
    ...
  
  @property
  def slope_scale(self):
    """Standard deviation of the slope transitions."""
    ...
  
  @property
  def observation_noise_scale(self):
    """Standard deviation of the observation noise."""
    ...
  


class LocalLinearTrend(StructuralTimeSeries):
  """Formal representation of a local linear trend model.

  The local linear trend model posits a `level` and `slope`, each
  evolving via a Gaussian random walk:

  ```
  level[t] = level[t-1] + slope[t-1] + Normal(0., level_scale)
  slope[t] = slope[t-1] + Normal(0., slope_scale)
  ```

  The latent state is the two-dimensional tuple `[level, slope]`. At each
  timestep we observe a noisy realization of the current level:
  `f[t] = level[t] + Normal(0., observation_noise_scale)`. This model
  is appropriate for data where the trend direction and magnitude (latent
  `slope`) is consistent within short periods but may evolve over time.

  Note that this model can produce very high uncertainty forecasts, as
  uncertainty over the slope compounds quickly. If you expect your data to
  have nonzero long-term trend, i.e. that slopes tend to revert to some mean,
  then the `SemiLocalLinearTrend` model may produce sharper forecasts.
  """
  def __init__(self, level_scale_prior=..., slope_scale_prior=..., initial_level_prior=..., initial_slope_prior=..., observed_time_series=..., name=...) -> None:
    """Specify a local linear trend model.

    Args:
      level_scale_prior: optional `tfd.Distribution` instance specifying a prior
        on the `level_scale` parameter. If `None`, a heuristic default prior is
        constructed based on the provided `observed_time_series`.
        Default value: `None`.
      slope_scale_prior: optional `tfd.Distribution` instance specifying a prior
        on the `slope_scale` parameter. If `None`, a heuristic default prior is
        constructed based on the provided `observed_time_series`.
        Default value: `None`.
      initial_level_prior: optional `tfd.Distribution` instance specifying a
        prior on the initial level. If `None`, a heuristic default prior is
        constructed based on the provided `observed_time_series`.
        Default value: `None`.
      initial_slope_prior: optional `tfd.Distribution` instance specifying a
        prior on the initial slope. If `None`, a heuristic default prior is
        constructed based on the provided `observed_time_series`.
        Default value: `None`.
      observed_time_series: optional `float` `Tensor` of shape
        `batch_shape + [T, 1]` (omitting the trailing unit dimension is also
        supported when `T > 1`), specifying an observed time series. Any `NaN`s
        are interpreted as missing observations; missingness may be also be
        explicitly specified by passing a `tfp.sts.MaskedTimeSeries` instance.
        Any priors not explicitly set will be given default values according to
        the scale of the observed time series (or batch of time series).
        Default value: `None`.
      name: the name of this model component.
        Default value: 'LocalLinearTrend'.
    """
    ...
  
  @property
  def initial_state_prior(self):
    """Prior distribution on the initial latent state (level and scale)."""
    ...
  



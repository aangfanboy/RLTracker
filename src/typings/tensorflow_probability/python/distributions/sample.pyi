"""
This type stub file was generated by pyright.
"""

from tensorflow_probability.python.bijectors import bijector as bijector_lib
from tensorflow_probability.python.distributions import distribution as distribution_lib

"""The Sample distribution class."""
class _Sample(distribution_lib.Distribution):
  """Distribution over IID samples of a given shape.

  Given random variable `X`, one may make a new random variable by concatenating
  samples.  For example, if `X1` and `X2` are iid `Normal(0, 1)` samples then
  `[X1, X2]` is a bi-variate normal random vector.

  #### Mathematical Details

  With `p` the probability density/mass of the function being sampled, and
  `n` the samples taken, the density/mass of this distribution is

  ```none
  p(x) = prod{ p(x[i]) : i = 0, ..., (n - 1) }
  ```

  #### Examples

  ```python
  tfd = tfp.distributions

  # Example 1: Five scalar draws.

  s = tfd.Sample(
        tfd.Normal(loc=0, scale=1),
        sample_shape=5)
  x = s.sample()
  # ==> x.shape: [5]

  lp = s.log_prob(x)
  # ==> lp.shape: []
  #     Equivalently: tf.reduce_sum(s.distribution.log_prob(x), axis=0)
  #
  # `Sample.log_prob` computes the per-{sample, batch} `log_prob`s then sums
  # over the `Sample.sample_shape` dimensions. In the above example `log_prob`
  # dims `0` is summed out, since it is the `sample_shape` dimension.

  # Example 2: `[5, 4]`-draws of a bivariate Normal.

  mvn = tfd.MultivariateNormalDiag(loc=tf.zeros([3, 2]))
  mvn.batch_shape ==> [3]
  mvn.event_shape ==> [2]

  s = tfd.Sample(mvn, sample_shape=[5, 4])
  s.batch_shape ==> [3]
  s.event_shape ==> [5, 4, 2]

  x = s.sample([6, 1])
  # ==> x.shape: [6, 1, 3, 5, 4, 2]

  lp = s.log_prob(x)
  # ==> lp.shape: [6, 1, 3]
  #
  # `s.log_prob` will reduce over the event dims of `mvn`, i.e., dim `5`, then
  # sums over `s.sample_shape` dims `[3, 4]` corresponding to shape (slice)
  # `[5, 4]`.
  ```

  """
  def __init__(self, distribution, sample_shape=..., validate_args=..., experimental_use_kahan_sum=..., name=...) -> None:
    """Construct the `Sample` distribution.

    The `event_shape` and `batch_shape` of the `Sample` distribution are
    determined by the args `distribution` and `sample_shape`:

    ```
    s = Sample(distribution, sample_shape)
    ==> s.batch_shape: distribution.batch_shape
    ==> s.event_shape: sample_shape + distribution.event_shape
    ```

    Args:
      distribution: The base distribution instance to transform. Typically an
        instance of `Distribution`.
      sample_shape: `int` scalar or vector `Tensor` representing the shape of a
        single sample.
      validate_args: Python `bool`.  Whether to validate input with asserts.
        If `validate_args` is `False`, and the inputs are invalid,
        correct behavior is not guaranteed.
      experimental_use_kahan_sum: Python `bool`. When `True`, we use Kahan
        summation to aggregate independent underlying log_prob values, which
        improves against the precision of a naive float32 sum. This can be
        noticeable in particular for large dimensions in float32. See CPU caveat
        on `tfp.math.reduce_kahan_sum`.
      name: The name for ops managed by the distribution.
        Default value: `None` (i.e., `'Sample' + distribution.name`).
    """
    ...
  
  @property
  def distribution(self): # -> Any:
    ...
  
  @property
  def sample_shape(self):
    ...
  
  @property
  def experimental_is_sharded(self):
    ...
  
  _mean = ...
  _stddev = ...
  _variance = ...
  _mode = ...


class Sample(_Sample, distribution_lib.AutoCompositeTensorDistribution):
  def __new__(cls, *args, **kwargs): # -> _Sample:
    """Maybe return a non-`CompositeTensor` `_Sample`."""
    ...
  


class _NonCompositeTensorDefaultSampleBijector(bijector_lib.Bijector):
  """Since tfd.Sample uses transposes, it requires a custom event bijector."""
  def __init__(self, distribution, sample_shape, sum_fn, bijector=...) -> None:
    ...
  


class _DefaultSampleBijector(_NonCompositeTensorDefaultSampleBijector, bijector_lib.AutoCompositeTensorBijector):
  """Since tfd.Sample uses transposes, it requires a custom event bijector."""
  def __new__(cls, *args, **kwargs): # -> _NonCompositeTensorDefaultSampleBijector:
    """Maybe return a `_NonCompositeTensorDefaultSampleBijector`."""
    ...
  



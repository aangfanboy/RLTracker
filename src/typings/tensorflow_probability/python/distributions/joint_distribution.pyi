"""
This type stub file was generated by pyright.
"""

import abc
import collections
import six
from tensorflow_probability.python.bijectors import bijector as bijector_lib, composition
from tensorflow_probability.python.distributions import distribution as distribution_lib
from tensorflow_probability.python.internal import auto_composite_tensor, docstring_util

"""The `JointDistribution` base class."""
__all__ = ['JointDistribution']
JAX_MODE = ...
@auto_composite_tensor.auto_composite_tensor
class StaticDistributionAttributes(auto_composite_tensor.AutoCompositeTensor):
  """Container to smuggle static attributes out of a tf.function trace."""
  def __init__(self, batch_shape, dtype, event_shape, experimental_shard_axis_names, name, reparameterization_type) -> None:
    ...
  
  def __iter__(self): # -> Iterator[Any]:
    """Yields parameters in order matching __init__ signature."""
    ...
  
  _composite_tensor_shape_params = ...


class ValueWithTrace(collections.namedtuple('ValueWithTrace', ['value', 'traced'])):
  """Represents an RV's realized value, and related quantity(s) to trace.

     Traced quantities may include the RV's distribution, log prob, etc. The
     realized value is not itself traced unless explicitly included in `traced`.

     During model execution, each call to `sample_and_trace_fn` returns a
     `ValueWithTrace` structure. The model uses the realized `value`, e.g., to
     define the distributions of downstream random variables, while the
     `traced` quantities are accumulated and returned to the caller (for JDs
     that use `vectorized_map`, they will be returned from inside the vmap, and
     so must be `Tensor`s or `BatchableCompositeTensor`s).

  Components:
    value: The realized value of this random variable. May be a Tensor or
      nested structure of Tensors.
    traced: Quantitiy(s) to be accumulated and
      returned from the execution of the probabilistic program. These
      may have any type (for example, they may be structures, contain
      `tfd.Distribution` instances, etc).
  """
  ...


def trace_distributions_and_values(dist, sample_shape, seed, value=...): # -> ValueWithTrace:
  """Draws a sample, and traces both the distribution and sampled value."""
  ...

def trace_distributions_only(dist, sample_shape, seed, value=...): # -> ValueWithTrace:
  """Draws a sample, and traces the sampled value."""
  ...

def trace_values_only(dist, sample_shape, seed, value=...): # -> ValueWithTrace:
  """Draws a sample, and traces the sampled value."""
  ...

def trace_values_and_log_probs(dist, sample_shape, seed, value=...): # -> ValueWithTrace:
  """Draws a sample, and traces both the sampled value and its log density."""
  ...

def trace_static_attributes(dist, sample_shape, seed, value): # -> ValueWithTrace:
  """Extracts the current distribution's static attributes as Tensor specs."""
  ...

CALLING_CONVENTION_DESCRIPTION = ...
FORBIDDEN_COMPONENT_NAMES = ...
@six.add_metaclass(abc.ABCMeta)
class JointDistribution(distribution_lib.Distribution):
  """Joint distribution over one or more component distributions.

  This distribution enables both sampling and joint probability computation from
  a single model specification.

  A joint distribution is a collection of possibly interdependent distributions.

  **Note**: unlike other non-`JointDistribution` distributions in
  `tfp.distributions`, `JointDistribution.sample` (and subclasses) return a
  structure of  `Tensor`s rather than a `Tensor`.  A structure can be a `list`,
  `tuple`, `dict`, `collections.namedtuple`, etc. Accordingly
  `joint.batch_shape` returns a structure of `TensorShape`s for each of the
  distributions' batch shapes and `joint.batch_shape_tensor()` returns a
  structure of `Tensor`s for each of the distributions' event shapes. (Same with
  `event_shape` analogues.)

  #### Subclass Requirements

  Subclasses implement:

  - `_model_coroutine`: A generator that yields a sequence of
    `tfd.Distribution`-like instances.

  - `_model_flatten`: takes a structured input and returns a sequence. The
    sequence order must match the order distributions are yielded from
    `_model_coroutine`.

  - `_model_unflatten`: takes a sequence and returns a structure matching the
    semantics of the `JointDistribution` subclass.

  """
  class Root(collections.namedtuple('Root', ['distribution'])):
    """Wrapper for coroutine distributions which lack distribution parents."""
    __slots__ = ...
  
  
  def __init__(self, dtype, validate_args, parameters, name, use_vectorized_map=..., batch_ndims=..., experimental_use_kahan_sum=...) -> None:
    ...
  
  @property
  def dtype(self):
    """The `DType` of `Tensor`s handled by this `Distribution`."""
    ...
  
  @property
  def reparameterization_type(self):
    """Describes how samples from the distribution are reparameterized.

    Currently this is one of the static instances
    `tfd.FULLY_REPARAMETERIZED` or `tfd.NOT_REPARAMETERIZED`.

    Returns:
      reparameterization_type: `ReparameterizationType` of each distribution in
        `model`.
    """
    ...
  
  @property
  def experimental_shard_axis_names(self):
    """Indicates whether part distributions have active shard axis names."""
    ...
  
  @property
  def use_vectorized_map(self): # -> bool:
    ...
  
  @property
  def batch_ndims(self): # -> None:
    ...
  
  def sample_distributions(self, sample_shape=..., seed=..., value=..., name=..., **kwargs): # -> tuple[Any, Any]:
    """Generate samples and the (random) distributions.

    Note that a call to `sample()` without arguments will generate a single
    sample.

    Args:
      sample_shape: 0D or 1D `int32` `Tensor`. Shape of the generated samples.
      seed: PRNG seed; see `tfp.random.sanitize_seed` for details.
      value: `list` of `Tensor`s in `distribution_fn` order to use to
        parameterize other ("downstream") distribution makers.
        Default value: `None` (i.e., draw a sample from each distribution).
      name: name prepended to ops created by this function.
        Default value: `"sample_distributions"`.
      **kwargs: This is an alternative to passing a `value`, and achieves the
        same effect. Named arguments will be used to parameterize other
        dependent ("downstream") distribution-making functions. If a `value`
        argument is also provided, raises a ValueError.

    Returns:
      distributions: a `tuple` of `Distribution` instances for each of
        `distribution_fn`.
      samples: a `tuple` of `Tensor`s with prepended dimensions `sample_shape`
        for each of `distribution_fn`.
    """
    ...
  
  @docstring_util.expand_docstring(calling_convention_description=CALLING_CONVENTION_DESCRIPTION.format(method='log_prob_parts', method_abbr='lp_parts'))
  def log_prob_parts(self, *args, **kwargs):
    """Log probability density/mass function.

    ${calling_convention_description}

    Returns:
      log_prob_parts: a `self.dtype`-like structure of `Tensor`s representing
        the `log_prob` for each component distribution evaluated at each
        corresponding `value`.
    """
    ...
  
  @docstring_util.expand_docstring(calling_convention_description=CALLING_CONVENTION_DESCRIPTION.format(method='prob_parts', method_abbr='p_parts'))
  def prob_parts(self, *args, **kwargs):
    """Probability density/mass function.

    ${calling_convention_description}

    Returns:
      prob_parts: a `self.dtype`-like structure of `Tensor`s representing the
        `prob` for each component distribution evaluated at each corresponding
        `value`.
    """
    ...
  
  @docstring_util.expand_docstring(calling_convention_description=CALLING_CONVENTION_DESCRIPTION.format(method='unnormalized_log_prob_parts', method_abbr='unnorm_lp_parts'))
  def unnormalized_log_prob_parts(self, *args, **kwargs):
    """Unnormalized log probability density/mass function.

    ${calling_convention_description}

    Returns:
      unnormalized_log_prob_parts: a `self.dtype`-like structure of `Tensor`s
        representing the `unnormalized_log_prob` for each component distribution
        evaluated at each corresponding `value`.
    """
    ...
  
  @docstring_util.expand_docstring(calling_convention_description=CALLING_CONVENTION_DESCRIPTION.format(method='unnormalized_prob_parts', method_abbr='unnorm_prob_parts'))
  def unnormalized_prob_parts(self, *args, **kwargs):
    """Unnormalized probability density/mass function.

    ${calling_convention_description}

    Returns:
      unnormalized_prob_parts: a `self.dtype`-like structure of `Tensor`s
        representing the `unnormalized_prob` for each component distribution
        evaluated at each corresponding `value`.
    """
    ...
  
  def is_scalar_event(self, name=...):
    """Indicates that `event_shape == []`.

    Args:
      name: Python `str` prepended to names of ops created by this function.

    Returns:
      is_scalar_event: `bool` scalar `Tensor` for each distribution in `model`.
    """
    ...
  
  def is_scalar_batch(self, name=...):
    """Indicates that `batch_shape == []`.

    Args:
      name: Python `str` prepended to names of ops created by this function.

    Returns:
      is_scalar_batch: `bool` scalar `Tensor` for each distribution in `model`.
    """
    ...
  
  @docstring_util.expand_docstring(calling_convention_description=CALLING_CONVENTION_DESCRIPTION.format(method='log_prob', method_abbr='lp'))
  def log_prob(self, *args, **kwargs):
    """Log probability density/mass function.

    ${calling_convention_description}

    Returns:
      log_prob: a `Tensor` of shape `sample_shape(x) + self.batch_shape` with
        values of type `self.dtype`.
    """
    ...
  
  @docstring_util.expand_docstring(calling_convention_description=CALLING_CONVENTION_DESCRIPTION.format(method='prob', method_abbr='prob'))
  def prob(self, *args, **kwargs):
    """Probability density/mass function.

    ${calling_convention_description}

    Returns:
      prob: a `Tensor` of shape `sample_shape(x) + self.batch_shape` with
        values of type `self.dtype`.
    """
    ...
  
  @docstring_util.expand_docstring(calling_convention_description=CALLING_CONVENTION_DESCRIPTION.format(method='unnormalized_log_prob', method_abbr='lp'))
  def unnormalized_log_prob(self, *args, **kwargs):
    """Unnormalized log probability density/mass function.

    ${calling_convention_description}

    Returns:
      log_prob: a `Tensor` of shape `sample_shape(x) + self.batch_shape` with
        values of type `self.dtype`.
    """
    ...
  
  def experimental_pin(self, *args, **kwargs): # -> JointDistributionPinned:
    """Pins some parts, returning an unnormalized distribution object.

    The calling convention is much like other `JointDistribution` methods (e.g.
    `log_prob`), but with the difference that not all parts are required. In
    this respect, the behavior is similar to that of the `sample` function's
    `value` argument.

    ### Examples:

    ```
    # Given the following joint distribution:
    jd = tfd.JointDistributionSequential([
        tfd.Normal(0., 1., name='z'),
        tfd.Normal(0., 1., name='y'),
        lambda y, z: tfd.Normal(y + z, 1., name='x')
    ], validate_args=True)

    # The following calls are all permissible and produce
    # `JointDistributionPinned` objects behaving identically.
    PartialXY = collections.namedtuple('PartialXY', 'x,y')
    PartialX = collections.namedtuple('PartialX', 'x')
    assert (jd.experimental_pin(x=2.).pins ==
            jd.experimental_pin(x=2., z=None).pins ==
            jd.experimental_pin(dict(x=2.)).pins ==
            jd.experimental_pin(dict(x=2., y=None)).pins ==
            jd.experimental_pin(PartialXY(x=2., y=None)).pins ==
            jd.experimental_pin(PartialX(x=2.)).pins ==
            jd.experimental_pin(None, None, 2.).pins ==
            jd.experimental_pin([None, None, 2.]).pins)
    ```

    Args:
      *args: Positional arguments: a value structure or component values (see
        above).
      **kwargs: Keyword arguments: a value structure or component values (see
        above). May also include `name`, specifying a Python string name for ops
        generated by this method.

    Returns:
      pinned: a `tfp.experimental.distributions.JointDistributionPinned` with
        the given values pinned.
    """
    ...
  


def get_explicit_name_for_component(d): # -> None:
  """Returns the explicitly-passed `name` of a Distribution, or None."""
  ...

def get_distribution_description(d, index): # -> str:
  """Returns a verbose description of a distribution for error messages."""
  ...

def maybe_check_wont_broadcast(flat_xs, validate_args): # -> tuple[Any, ...]:
  """Verifies that `parts` don't broadcast."""
  ...

class _DefaultJointBijector(composition.Composition):
  """Minimally-viable event space bijector for `JointDistribution`."""
  def __init__(self, jd, parameters=..., bijector_fn=...) -> None:
    ...
  


class _DefaultJointBijectorAutoBatched(bijector_lib.Bijector):
  """Automatically vectorized support bijector for autobatched JDs."""
  def __init__(self, jd, **kwargs) -> None:
    ...
  



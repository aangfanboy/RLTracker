"""
This type stub file was generated by pyright.
"""

from tensorflow_probability.python.distributions import distribution as distribution_lib

"""The Blockwise distribution."""
class _NonCompositeTensorCast(distribution_lib.Distribution):
  """Utility distribution to cast inputs/outputs of another distribution."""
  def __init__(self, distribution, dtype) -> None:
    ...
  


class _Cast(_NonCompositeTensorCast, distribution_lib.AutoCompositeTensorDistribution):
  """Utility distribution to cast inputs/outputs of another distribution."""
  def __new__(cls, *args, **kwargs): # -> _NonCompositeTensorCast:
    """Maybe return a `_NonCompositeTensorCast`."""
    ...
  


class _Blockwise(distribution_lib.Distribution):
  """Blockwise distribution.

  This distribution converts a distribution or list of distributions into a
  vector-variate distribution by doing a sequence of reshapes and concatenating
  the results. This is particularly useful for converting `JointDistribution`
  instances to vector-variate for downstream uses which can only handle
  single-`Tensor` distributions.

  #### Examples

  Flattening a sequence of distrbutions:

  ```python
  tfd = tfp.distributions

  d = tfd.Blockwise(
      [
          tfd.Independent(
              tfd.Normal(
                  loc=tf.zeros(4, dtype=tf.float64),
                  scale=1),
              reinterpreted_batch_ndims=1),
          tfd.MultivariateNormalTriL(
              scale_tril=tf.eye(2, dtype=tf.float32)),
      ],
      dtype_override=tf.float32,
  )
  x = d.sample([2, 1])
  y = d.log_prob(x)
  x.shape  # ==> (2, 1, 4 + 2)
  x.dtype  # ==> tf.float32
  y.shape  # ==> (2, 1)
  y.dtype  # ==> tf.float32

  d.mean()  # ==> np.zeros((4 + 2,))
  ```

  Flattening a joint distribution:

  ```python
  tfd = tfp.distributions

  Root = tfd.JointDistributionCoroutine.Root  # Convenient alias.
  def model():
    e = yield Root(tfd.Independent(tfd.Exponential(rate=[100, 120]), 1))
    g = yield tfd.Gamma(concentration=e[..., 0], rate=e[..., 1])
    n = yield Root(tfd.Normal(loc=0, scale=2.))
    yield tfd.Normal(loc=n, scale=g)

  joint = tfd.JointDistributionCoroutine(model)
  d = tfd.Blockwise(joint)

  x = d.sample([2, 1])
  y = d.log_prob(x)
  x.shape  # ==> (2, 1, 2 + 1 + 1 + 1)
  x.dtype  # ==> tf.float32
  y.shape  # ==> (2, 1)
  y.dtype  # ==> tf.float32
  ```

  """
  def __init__(self, distributions, dtype_override=..., validate_args=..., allow_nan_stats=..., name=...) -> None:
    """Construct the `Blockwise` distribution.

    Args:
      distributions: Python `list` of `tfp.distributions.Distribution`
        instances or a single `tfp.distributions.JointDistribution` instance.
        If `list`, all distribution instances must have the same `batch_shape`
        and all must have `event_ndims==1`, i.e., be vector-variate
        distributions.
      dtype_override: samples of `distributions` will be cast to this `dtype`.
        If unspecified, all `distributions` must have the same `dtype`.
        Default value: `None` (i.e., do not cast).
      validate_args: Python `bool`, default `False`. When `True` distribution
        parameters are checked for validity despite possibly degrading runtime
        performance. When `False` invalid inputs may silently render incorrect
        outputs.
      allow_nan_stats: Python `bool`, default `True`. When `True`, statistics
        (e.g., mean, mode, variance) use the value "`NaN`" to indicate the
        result is undefined. When `False`, an exception is raised if one or more
        of the statistic's batch members are undefined.
      name: Python `str` name prefixed to Ops created by this class.
    """
    ...
  
  @property
  def distributions(self): # -> Any:
    ...
  
  @property
  def experimental_is_sharded(self): # -> bool:
    ...
  


class Blockwise(_Blockwise, distribution_lib.AutoCompositeTensorDistribution):
  def __new__(cls, *args, **kwargs): # -> _Blockwise:
    """Maybe return a non-`CompositeTensor` `_Blockwise`."""
    ...
  



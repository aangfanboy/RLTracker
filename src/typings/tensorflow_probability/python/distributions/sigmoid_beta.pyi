"""
This type stub file was generated by pyright.
"""

from tensorflow_probability.python.distributions import distribution

"""The SigmoidBeta distribution class."""
__all__ = ['SigmoidBeta']
class SigmoidBeta(distribution.AutoCompositeTensorDistribution):
  """SigmoidBeta Distribution.

  The SigmoidBeta distribution is defined over the real line using parameters
  `concentration1` (aka 'alpha') and `concentration0` (aka 'beta').

  This distribution is the transformation of the Beta distribution such that
  Sigmoid(X) ~ Beta(...) => X ~ SigmoidBeta(...).

  #### Mathematical Details

  The probability density function (pdf) can be derived from the change of
  variables rule. We begin with `g(X) = Sigmoid(X)`, and note that

  ```none
  p_x(x) = p_y(g(y)) | g'(y) |.
  ```
  With `g'(y) = Sigmoid(x) ( 1 - Sigmoid(x))`, we arrive at

  ```none
  pdf(x; alpha, beta) = Sigmoid(x)^alpha (1 - Sigmoid(x))^beta / B(alpha, beta)
  B(alpha, beta) = Gamma(alpha) Gamma(beta) / Gamma(alpha + beta)
  ```
  where:

  * `concentration1 = alpha`
  * `concentration0 = beta`
  * `B(alpha, beta` is the [beta function](
    https://en.wikipedia.org/wiki/Beta_function)
  * `Gamma` is the [gamma function](
    https://en.wikipedia.org/wiki/Gamma_function).

  Critically, these parameters lose the relationship to the mean that they have
  under the untransformed Beta distribution. We choose to keep the names to
  draw analogy to the original Beta distribution.

  ```none
  concentration1 = alpha
  concentration0 = beta
  ```

  Distribution parameters are automatically broadcast in all functions; see
  examples for details.



  The cumlative density function (cdf) can be found by integrating the pdf
  directly from `-infinity` to x:

  ```none
   cdf(x; alpha, beta) = I_Sigmoid(x)(alpha + 1, beta + 1) / B(alpha, beta),
  ```

  where `I_x(alpha, beta)` is the [incomplete beta function](
  https://en.wikipedia.org/wiki/Beta_function#Incomplete_beta_function).

  Samples of this distribution are reparameterized (pathwise differentiable).
  The derivatives are computed using the approach described in
  [(Figurnov et al., 2018)][1].

  #### Examples

   ```python
   tfd = tfp.distributions

   dist = tfd.SigmoidBeta(concentration0=1.,
                          concentration1=2.)

   dist.sample([4, 5])  # Shape [4, 5, 3]

   # `x` has three batch entries, each with two samples.
   x = [[.1, .4, .5],
        [.2, .3, .5]]
   # Calculate the probability of each pair of samples under the corresponding
   # distribution in `dist`.
   dist.prob(x)         # Shape [2, 3]
   ```

  #### References

  [1]: Michael Figurnov, Shakir Mohamed, Andriy Mnih.
       Implicit Reparameterization Gradients. _arXiv preprint arXiv:1805.08498_,
       2018. https://arxiv.org/abs/1805.08498

  """
  def __init__(self, concentration1, concentration0, validate_args=..., allow_nan_stats=..., name=...) -> None:
    """Initialize a batch of SigmoidBeta distributions.

    Args:
      concentration1: Positive floating-point `Tensor` indicating mean
        number of successes; aka 'alpha'.
      concentration0: Positive floating-point `Tensor` indicating mean
        number of failures; aka 'beta'.
      validate_args: Python `bool`, default `False`. When `True` distribution
        parameters are checked for validity despite possibly degrading runtime
        performance. When `False` invalid inputs may silently render incorrect
        outputs.
      allow_nan_stats: Python `bool`, default `True`. When `True`, statistics
        (e.g., mean, mode, variance) use the value '`NaN`' to indicate the
        result is undefined. When `False`, an exception is raised if one or
        more of the statistic's batch members are undefined.
      name: Python `str` name prefixed to Ops created by this class.
    """
    ...
  
  @property
  def concentration1(self):
    """Concentration parameter associated with a `1` outcome."""
    ...
  
  @property
  def concentration0(self):
    """Concentration parameter associated with a `0` outcome."""
    ...
  


